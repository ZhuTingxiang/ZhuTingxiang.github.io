<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Star</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-06-16T23:07:19.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Star</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 142. Linked List CycleII</title>
    <link href="http://yoursite.com/2017/06/16/LeetCode-142-Linked-List-CycleII/"/>
    <id>http://yoursite.com/2017/06/16/LeetCode-142-Linked-List-CycleII/</id>
    <published>2017-06-16T23:04:56.000Z</published>
    <updated>2017-06-16T23:07:19.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><h3 id="question">Question</h3>
<p>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p>
<p>Note: Do not modify the linked list.</p>
<p>Follow up:
Can you solve it without using extra space?</p>
<h3 id="explanation">Explanation</h3>
<p>和上面一道题不一样的地方就是要输出从哪里开始。真的是不看答案想不出来..贴一个我觉得比较清楚的讲解吧：
Reference：https://discuss.leetcode.com/topic/27868/concise-java-solution-based-on-slow-fast-pointers
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Definitions:</div><div class="line">Cycle = length of the cycle, if exists.</div><div class="line">C is the beginning of Cycle, S is the distance of slow pointer from C when slow pointer meets fast pointer.</div><div class="line"></div><div class="line">Distance(slow) = C + S, Distance(fast) = 2 * Distance(slow) = 2 * (C + S). To let slow poiner meets fast pointer, only if fast pointer run 1 cycle more than slow pointer. Distance(fast) - Distance(slow) = Cycle</div><div class="line">=&gt; 2 * (C + S) - (C + S)	= Cycle</div><div class="line">=&gt;	C + S = Cycle</div><div class="line">=&gt;	C = Cycle - S</div><div class="line">=&gt; This means if slow pointer runs (Cycle - S) more, it will reaches C. So at this time, if there&apos;s another point2 running from head</div><div class="line">=&gt; After C distance, point2 will meet slow pointer at C, where is the beginning of the cycle.</div></pre></td></tr></table></figure></p>
<h3 id="code">Code</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">public ListNode detectCycle(ListNode head) &#123;</div><div class="line">	ListNode slow = head, fast = head;</div><div class="line">	while(fast != null &amp;&amp; fast.next != null) &#123;</div><div class="line">		fast = fast.next.next;</div><div class="line">		slow = slow.next;</div><div class="line">		if (slow == fast) &#123;</div><div class="line">			while (head != slow) &#123;</div><div class="line">				head = head.next;</div><div class="line">				slow = slow.next;</div><div class="line">			&#125;</div><div class="line">			return slow;				</div><div class="line">		&#125;</div><div class="line">	&#125;			</div><div class="line">	return null;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;question&quot;&gt;Question&lt;/h3&gt;
&lt;p&gt;Given a linked list, return the node where the cycle be
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="LinkedList" scheme="http://yoursite.com/tags/LinkedList/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 141. Linked List Cycle</title>
    <link href="http://yoursite.com/2017/06/16/LeetCode-141-Linked-List-Cycle/"/>
    <id>http://yoursite.com/2017/06/16/LeetCode-141-Linked-List-Cycle/</id>
    <published>2017-06-16T21:24:02.000Z</published>
    <updated>2017-06-16T21:36:55.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><h3 id="question">Question</h3>
<p>Given a linked list, determine if it has a cycle in it.</p>
<p>Follow up:
Can you solve it without using extra space?</p>
<h3 id="explanation">Explanation</h3>
<p>双指针，如果有重合，就说明有环。</p>
<h3 id="code">Code</h3>
<p>public class Solution {
// Solution 1: user extra space, O(N). Time complexity:O(N). HashSet;
// public boolean hasCycle(ListNode head) {
//     if (head == null) return false;
//     ListNode n = head;
//     HashSet&lt;ListNode&gt; set = new HashSet&lt;&gt;();
//     while(n!=null) {
//         if (!set.contains(n)) set.add(n);
//         else return true;
//         n = n.next;
//     }
//     return false;
// }
// Solution 2: two pointers
public boolean hasCycle(ListNode head) {
if (head == null) return false;
ListNode walker, runner;
walker = head;
runner = head;
while (runner != null &amp;&amp; runner.next != null) {
runner = runner.next.next;
walker = walker.next;
if (runner == walker) return true;
}
return false;</p>
<pre><code>      }
  }



}
</code></pre>
<p>}</p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;question&quot;&gt;Question&lt;/h3&gt;
&lt;p&gt;Given a linked list, determine if it has a cycle in it.
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="LinkedList" scheme="http://yoursite.com/tags/LinkedList/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 138. Copy List with Random Pointer</title>
    <link href="http://yoursite.com/2017/06/16/LeetCode-138-Copy-List-with-Random-Pointer/"/>
    <id>http://yoursite.com/2017/06/16/LeetCode-138-Copy-List-with-Random-Pointer/</id>
    <published>2017-06-16T21:14:28.000Z</published>
    <updated>2017-06-16T21:17:04.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><h3 id="question">Question</h3>
<p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p>
<p>Return a deep copy of the list.</p>
<h3 id="explanation">Explanation</h3>
<p>这道题有两种解法。一种用Hashmap存每个节点，然后复制。这种需要占用Extra space。另外一种就是把每个新的节点存到原来的节点的下一个，不用额外空间。</p>
<h3 id="code">Code</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    // Solution 1: using hashmap and iterate twice. one for nodes, the other for next and random.</div><div class="line">    public RandomListNode copyRandomList(RandomListNode head) &#123;</div><div class="line">        HashMap&lt;RandomListNode, RandomListNode&gt; map = new HashMap&lt;&gt;();</div><div class="line">        RandomListNode curr = head;</div><div class="line">        // copy the all the nodes and their labels first</div><div class="line">        while (curr != null) &#123;</div><div class="line">            map.put(curr, new RandomListNode(curr.label));</div><div class="line">            curr = curr.next;</div><div class="line">        &#125;</div><div class="line">        RandomListNode node = head;</div><div class="line">        // copy all the next and randoms</div><div class="line">        while (node != null) &#123;</div><div class="line">            map.get(node).next = map.get(node.next);</div><div class="line">            map.get(node).random = map.get(node.random);</div><div class="line">            node = node.next;</div><div class="line">        &#125;</div><div class="line">        return map.get(head);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Solution 2: no hashmap, only linked list</div><div class="line">    public RandomListNode copyRandomList(RandomListNode head) &#123;</div><div class="line">        if (head == null) return null;</div><div class="line">        RandomListNode curr = head;</div><div class="line">        // copy next</div><div class="line">        while (curr != null) &#123;</div><div class="line">            RandomListNode newNode = new RandomListNode(curr.label);</div><div class="line">            newNode.random = curr.random;</div><div class="line">            newNode.next = curr.next;</div><div class="line">            curr.next = newNode;</div><div class="line">            curr = curr.next.next;</div><div class="line">        &#125;</div><div class="line">        // copy random</div><div class="line">        RandomListNode cur = head;</div><div class="line"></div><div class="line">        while (cur != null) &#123;</div><div class="line">            if (cur.next.random != null) &#123;</div><div class="line">                cur.next.random = cur.random.next;</div><div class="line">            &#125;</div><div class="line">            cur = cur.next.next;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // split list</div><div class="line">        RandomListNode newHead = head.next;</div><div class="line">        RandomListNode curt = head;</div><div class="line">        while (curt != null) &#123;</div><div class="line">            RandomListNode tmp= curt.next;</div><div class="line">            curt.next = tmp.next;</div><div class="line">            curt = curt.next;</div><div class="line">            if (tmp.next != null) &#123;</div><div class="line">                tmp.next = tmp.next.next;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        return newHead;</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;question&quot;&gt;Question&lt;/h3&gt;
&lt;p&gt;A linked list is given such that each node contains an 
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="LinkedList" scheme="http://yoursite.com/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 25. Reverse Nodes in k-Group</title>
    <link href="http://yoursite.com/2017/06/16/LeetCode-25-Reverse-Nodes-in-k-Group/"/>
    <id>http://yoursite.com/2017/06/16/LeetCode-25-Reverse-Nodes-in-k-Group/</id>
    <published>2017-06-16T18:00:54.000Z</published>
    <updated>2017-06-16T18:03:07.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><h3 id="question">Question</h3>
<p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</p>
<p>k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.</p>
<p>You may not alter the values in the nodes, only nodes itself may be changed.</p>
<p>Only constant memory is allowed.</p>
<p>For example,
Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5</p>
<p>For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5</p>
<p>For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5</p>
<h3 id="explanation">Explanation</h3>
<p>这道题和之前的reverse nodes II很像，有一个范围，你要写一个reverse函数去在这个范围内reverse一下linked list。 其他不难，主要还是想清楚翻转的过程。</p>
<h3 id="code">Code</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">     private static ListNode reverse(ListNode pre, ListNode next)&#123;</div><div class="line">         ListNode last = pre.next;</div><div class="line">         ListNode cur = last.next;</div><div class="line">         while (cur != next) &#123;</div><div class="line">             last.next = cur.next;</div><div class="line">             cur.next = pre.next;</div><div class="line">             pre.next = cur;</div><div class="line">             cur = last.next;</div><div class="line">         &#125;</div><div class="line">         return last;</div><div class="line">     &#125;</div><div class="line"></div><div class="line"></div><div class="line">     public static ListNode reverseKGroup(ListNode head, int k) &#123;</div><div class="line">         if (head == null || k== 1) return head;</div><div class="line">         ListNode dummy = new ListNode(0);</div><div class="line">         dummy.next = head;</div><div class="line">         int count = 0;</div><div class="line">         ListNode pre = dummy;</div><div class="line">         ListNode cur = head;</div><div class="line">         while (cur != null) &#123;</div><div class="line">             count ++;</div><div class="line">             ListNode next = cur.next;</div><div class="line">             if (count == k) &#123;</div><div class="line">                 pre = reverse(pre, next);</div><div class="line">                 count = 0;</div><div class="line">             &#125;</div><div class="line">             cur = next;</div><div class="line">         &#125;</div><div class="line">         return dummy.next;</div><div class="line"></div><div class="line">     &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;question&quot;&gt;Question&lt;/h3&gt;
&lt;p&gt;Given a linked list, reverse the nodes of a linked list
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="LinkedList" scheme="http://yoursite.com/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 92. Reverse LinkedList II</title>
    <link href="http://yoursite.com/2017/06/15/LeetCode-92-Reverse-LinkedList-II/"/>
    <id>http://yoursite.com/2017/06/15/LeetCode-92-Reverse-LinkedList-II/</id>
    <published>2017-06-15T23:47:25.000Z</published>
    <updated>2017-06-15T23:53:29.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><h3 id="question">Question</h3>
<p>Reverse a linked list from position m to n. Do it in-place and in one-pass.</p>
<p>For example:
Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2 and n = 4,</p>
<p>return 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL.</p>
<p>Note:
Given m, n satisfy the following condition:
1 ≤ m ≤ n ≤ length of list.</p>
<h3 id="explanation">Explanation</h3>
<p>这道题就是将m到n范围内的链表翻转。注意三个点，一个pre，一个curr，一个next。好搞啊..</p>
<h3 id="code">Code</h3>
<pre><code>public class Solution {
    public ListNode reverseBetween(ListNode head, int m, int n) {
        if (head == null) return null;
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode pre = dummy;
        //Find m node
        for (int i=1; i&lt; m; i++) {
            pre = pre.next;
        }
        // 1 - 2 -3 - 4 - 5 ; m=2; n =4 ---&gt; pre = 1, start = 2, then = 3
        // dummy-&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5

        ListNode start = pre.next;
        ListNode curr = start.next;
        for (int i=m; i&lt;n; i++) {
            ListNode next = curr.next;
            curr.next = pre.next;
            pre.next = curr;
            start.next = next;
            curr = next;
        }

        // first reversing : dummy-&gt;1 - 3 - 2 - 4 - 5; pre = 1, start = 2, then = 4
        // second reversing: dummy-&gt;1 - 4 - 3 - 2 - 5; pre = 1, start = 2, then = 5 (finish)
        return dummy.next;

    }
}

``
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;question&quot;&gt;Question&lt;/h3&gt;
&lt;p&gt;Reverse a linked list from position m to n. Do it in-pl
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="LinkedList" scheme="http://yoursite.com/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 47.Permutations II</title>
    <link href="http://yoursite.com/2017/06/12/LeetCode-47-Permutations-II/"/>
    <id>http://yoursite.com/2017/06/12/LeetCode-47-Permutations-II/</id>
    <published>2017-06-13T03:30:01.000Z</published>
    <updated>2017-06-13T03:33:53.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><h3 id="question">Question</h3>
<p>Given a collection of numbers that might contain duplicates, return all possible unique permutations.</p>
<p>For example,
[1,1,2] have the following unique permutations:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [1,1,2],</div><div class="line">  [1,2,1],</div><div class="line">  [2,1,1]</div><div class="line">]</div></pre></td></tr></table></figure></p>
<h3 id="explanation">Explanation</h3>
<p>和之前一道题相似，只是注意一下这里是可以重复的。</p>
<h3 id="code">Code</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123;</div><div class="line">        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();</div><div class="line">        int[] visited = new int[nums.length];</div><div class="line">        if (nums == null || nums.length == 0) return result;</div><div class="line">        for (int i=0; i&lt;nums.length; i++) &#123;</div><div class="line">            visited[i] = 0;</div><div class="line">        &#125;</div><div class="line">        Arrays.sort(nums);</div><div class="line">        helper(nums, new ArrayList&lt;Integer&gt;(), result, visited);</div><div class="line">        return result;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    public void helper(int[] nums,  List&lt;Integer&gt; list, List&lt;List&lt;Integer&gt;&gt; result, int[] visited) &#123;</div><div class="line">        if (list.size() == nums.length) &#123;</div><div class="line">            result.add(new ArrayList&lt;Integer&gt;(list));</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        for (int i=0; i&lt;nums.length; i++) &#123;</div><div class="line">            // 判断是否访问过，或者是否排在前面的相同的没有使用。</div><div class="line">            if (visited[i] == 1 || (i!=0 &amp;&amp; nums[i] == nums[i-1]&amp;&amp; visited[i-1] == 0)) continue;</div><div class="line">            visited[i] = 1;</div><div class="line"></div><div class="line">            list.add(nums[i]);</div><div class="line">            helper(nums, list, result, visited);</div><div class="line">            list.remove(list.size()-1);</div><div class="line">            visited[i] = 0;</div><div class="line">        &#125;  </div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;question&quot;&gt;Question&lt;/h3&gt;
&lt;p&gt;Given a collection of numbers that might contain duplic
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 46.Permutations</title>
    <link href="http://yoursite.com/2017/06/12/LeetCode-46-Permutations/"/>
    <id>http://yoursite.com/2017/06/12/LeetCode-46-Permutations/</id>
    <published>2017-06-13T02:49:23.000Z</published>
    <updated>2017-06-13T02:51:34.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><h3 id="quesiton">Quesiton</h3>
<p>Given a collection of distinct numbers, return all possible permutations.</p>
<p>For example,
[1,2,3] have the following permutations:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [1,2,3],</div><div class="line">  [1,3,2],</div><div class="line">  [2,1,3],</div><div class="line">  [2,3,1],</div><div class="line">  [3,1,2],</div><div class="line">  [3,2,1]</div><div class="line">]</div></pre></td></tr></table></figure></p>
<h4 id="explanation">Explanation</h4>
<p>这道题是排列组合问题，所以用DFS和回溯法递归。注意长度要和原来的数组长度相等。</p>
<h3 id="code">Code</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;</div><div class="line">        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();</div><div class="line">        helper(nums, new ArrayList&lt;Integer&gt;(), result);</div><div class="line">        return result;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    public void helper(int[] nums,  List&lt;Integer&gt; list, List&lt;List&lt;Integer&gt;&gt; result) &#123;</div><div class="line">        if (list.size() == nums.length) &#123;</div><div class="line">            result.add(new ArrayList&lt;Integer&gt;(list));</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        for (int i=0; i&lt;nums.length; i++) &#123;</div><div class="line">            if (list.contains(nums[i])) continue;</div><div class="line">            list.add(nums[i]);</div><div class="line">            helper(nums, list, result);</div><div class="line">            list.remove(list.size()-1);</div><div class="line">        &#125;  </div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;quesiton&quot;&gt;Quesiton&lt;/h3&gt;
&lt;p&gt;Given a collection of distinct numbers, return all poss
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 40. Combination Sum II</title>
    <link href="http://yoursite.com/2017/06/12/LeetCode-40-Combination-Sum-II/"/>
    <id>http://yoursite.com/2017/06/12/LeetCode-40-Combination-Sum-II/</id>
    <published>2017-06-12T21:19:22.000Z</published>
    <updated>2017-06-12T21:20:43.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><h3 id="question">Question</h3>
<p>Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.</p>
<p>Each number in C may only be used once in the combination.</p>
<p>Note:
All numbers (including target) will be positive integers.
The solution set must not contain duplicate combinations.
For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,
A solution set is:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [1, 7],</div><div class="line">  [1, 2, 5],</div><div class="line">  [2, 6],</div><div class="line">  [1, 1, 6]</div><div class="line">]</div></pre></td></tr></table></figure></p>
<h3 id="explanation">Explanation</h3>
<p>其实相比1还要简单一些。用DFS找到所有的组合，注意去重。</p>
<h3 id="code">Code</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public class Solution &#123;</div><div class="line"></div><div class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123;</div><div class="line">        List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();</div><div class="line">        if (candidates == null || candidates.length == 0) return list;</div><div class="line">        Arrays.sort(candidates);</div><div class="line">        helper(candidates, 0, target, new ArrayList&lt;Integer&gt;(), list);</div><div class="line"></div><div class="line">        return list;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    // 在list[index:]中选取和为target的所有组合，添加到combination之后，整个放到combinations当中</div><div class="line">    public void helper(int[] candidates, int startIndex, int target, List&lt;Integer&gt; combination, List&lt;List&lt;Integer&gt;&gt; list) &#123;</div><div class="line">        if (target == 0) list.add(new ArrayList&lt;Integer&gt;(combination));</div><div class="line">        for(int i=startIndex; i&lt; candidates.length; i++) &#123;</div><div class="line">            if (i &gt;startIndex &amp;&amp; candidates[i] == candidates[i-1]) continue; //去重的重要步骤，因为数列是升序。</div><div class="line">            if (target &lt; candidates[i]) &#123;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            combination.add(candidates[i]);</div><div class="line">            helper(candidates, i+1, target - candidates[i], combination,list);</div><div class="line">            combination.remove(combination.size()-1);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;question&quot;&gt;Question&lt;/h3&gt;
&lt;p&gt;Given a collection of candidate numbers (C) and a targe
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="Recursive" scheme="http://yoursite.com/tags/Recursive/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 39. Combination Sum</title>
    <link href="http://yoursite.com/2017/06/12/LeetCode-39-Combination-Sum/"/>
    <id>http://yoursite.com/2017/06/12/LeetCode-39-Combination-Sum/</id>
    <published>2017-06-12T21:02:47.000Z</published>
    <updated>2017-06-12T21:19:08.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><h3 id="question">Question</h3>
<p>Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.</p>
<p>The same repeated number may be chosen from C unlimited number of times.</p>
<p>Note:
All numbers (including target) will be positive integers.
The solution set must not contain duplicate combinations.
For example, given candidate set [2, 3, 6, 7] and target 7,
A solution set is:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [7],</div><div class="line">  [2, 2, 3]</div><div class="line">]</div></pre></td></tr></table></figure></p>
<h3 id="explanation">Explanation</h3>
<p>对于这类求所有组合的题目，必然用DFS来做。注意这里数字是可以重复用的，所以在helper递归的时候还用原来的index。</p>
<h3 id="code">Code</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line"></div><div class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;</div><div class="line">        List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();</div><div class="line">        if (candidates == null || candidates.length == 0) return list;</div><div class="line">        Arrays.sort(candidates);</div><div class="line">        helper(candidates, 0, target, new ArrayList&lt;Integer&gt;(), list);</div><div class="line"></div><div class="line">        return list;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    // 在list[index:]中选取和为target的所有组合，添加到combination之后，整个放到combinations当中</div><div class="line">    public void helper(int[] candidates, int startIndex, int target, List&lt;Integer&gt; combination, List&lt;List&lt;Integer&gt;&gt; list) &#123;</div><div class="line">        if (target == 0) list.add(new ArrayList&lt;Integer&gt;(combination));</div><div class="line">        for(int i=startIndex; i&lt; candidates.length; i++) &#123;</div><div class="line">            if (target &lt; candidates[i]) &#123;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            combination.add(candidates[i]);</div><div class="line">            helper(candidates, i, target - candidates[i], combination,list);</div><div class="line">            combination.remove(combination.size()-1);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;question&quot;&gt;Question&lt;/h3&gt;
&lt;p&gt;Given a set of candidate numbers (C) (without duplicate
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="Recursive" scheme="http://yoursite.com/tags/Recursive/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 127. Word Ladder</title>
    <link href="http://yoursite.com/2017/06/12/LeetCode-127-Word-Ladder/"/>
    <id>http://yoursite.com/2017/06/12/LeetCode-127-Word-Ladder/</id>
    <published>2017-06-12T19:13:14.000Z</published>
    <updated>2017-06-12T20:11:13.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><h3 id="question">Question</h3>
<h3 id="explanation">Explanation</h3>
<p>本题用DFS做会严重超时，用BFS也要注意一下替换的方式。其实用双边BFS会更快。</p>
<h3 id="code">Code</h3>
<p>Solution 1: BFS
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) &#123;</div><div class="line">        Set&lt;String&gt; dict = new HashSet&lt;&gt;();</div><div class="line">        for (String word : wordList) &#123;</div><div class="line">            dict.add(word);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (wordList == null) return 0;</div><div class="line">        if (beginWord.equals(endWord)) return 1;</div><div class="line">        // wordList.add(beginWord);</div><div class="line">        // wordList.add(endWord);</div><div class="line"></div><div class="line">        HashSet&lt;String&gt; hash = new HashSet&lt;&gt;();</div><div class="line">        Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();</div><div class="line">        queue.offer(beginWord);</div><div class="line">        hash.add(beginWord);</div><div class="line"></div><div class="line">        int length = 1;</div><div class="line">        while(!queue.isEmpty()) &#123;</div><div class="line">            length ++;</div><div class="line">            int size = queue.size();</div><div class="line">            for(int i=0; i&lt;size; i++) &#123;</div><div class="line">                String word = queue.poll();</div><div class="line">                for (String nextWord: getNextWords(word, dict)) &#123;</div><div class="line">                    if (hash.contains(nextWord)) &#123;</div><div class="line">                        continue;</div><div class="line">                    &#125;</div><div class="line">                    if (nextWord.equals(endWord)) &#123;</div><div class="line">                        return length;</div><div class="line">                    &#125;</div><div class="line">                    hash.add(nextWord);</div><div class="line">                    queue.offer(nextWord);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private List&lt;String&gt; getNextWords(String word, Set&lt;String&gt; wordList) &#123;</div><div class="line">        List&lt;String&gt; nextWords = new ArrayList&lt;&gt;();</div><div class="line">        for (char c = &apos;a&apos; ; c &lt;&apos;z&apos;; c++) &#123;</div><div class="line">            for (int i=0; i&lt; word.length(); i++)&#123;</div><div class="line">                if (c == word.charAt(i)) &#123;</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line">                String nextWord = replace(word, i, c);</div><div class="line">                if (wordList.contains(nextWord)) &#123;</div><div class="line">                    nextWords.add(nextWord);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return nextWords;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private String replace(String word, int i, char c) &#123;</div><div class="line">        char[] chars = word.toCharArray();</div><div class="line">        chars[i] = c;</div><div class="line">        return new String(chars);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;question&quot;&gt;Question&lt;/h3&gt;
&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;
&lt;p&gt;本题用DFS做会严重超时，用BFS
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="Google" scheme="http://yoursite.com/tags/Google/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="biaBFS" scheme="http://yoursite.com/tags/biaBFS/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 73. Set Matrix Zeroes</title>
    <link href="http://yoursite.com/2017/06/11/LeetCode-73-Set-Matrix-Zeroes/"/>
    <id>http://yoursite.com/2017/06/11/LeetCode-73-Set-Matrix-Zeroes/</id>
    <published>2017-06-11T21:42:55.000Z</published>
    <updated>2017-06-11T21:46:14.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><h3 id="quesiton">Quesiton</h3>
<p>Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place.</p>
<p>click to show follow up.</p>
<p>Follow up:
Did you use extra space?
A straight forward solution using O(mn) space is probably a bad idea.
A simple improvement uses O(m + n) space, but still not the best solution.
Could you devise a constant space solution?</p>
<h3 id="explanation">Explanation</h3>
<p>主题思想就是利用第一行和第一列来记录哪些行和列需要标记为0。同时，用两个boolean变量标记第一行和第一列本身是否需要标记为0。</p>
<h3 id="code">Code</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">public void setZeroes(int[][] matrix) &#123;</div><div class="line">    if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return;</div><div class="line">    int m = matrix.length, n = matrix[0].length;</div><div class="line">    boolean row = false, col = false;</div><div class="line">    for (int i = 0; i &lt; m; i++)</div><div class="line">        for (int j = 0; j &lt; n; j++)&#123;</div><div class="line">            if (matrix[i][j] == 0) &#123;</div><div class="line">                matrix[0][j] = 0;</div><div class="line">                matrix[i][0] = 0;</div><div class="line">                if (i == 0) row = true;</div><div class="line">                if (j == 0) col = true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    for (int i = 1; i &lt; m; i++)&#123;</div><div class="line">        if (matrix[i][0] == 0)&#123;</div><div class="line">            for (int j = 1; j &lt; n;j++)</div><div class="line">                matrix[i][j] = 0;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    for (int j = 1; j &lt; n; j++)&#123;</div><div class="line">        if (matrix[0][j] == 0)&#123;</div><div class="line">            for (int i = 1; i &lt; m; i++)</div><div class="line">                matrix[i][j] = 0;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (row)&#123;</div><div class="line">        for (int j = 0; j &lt; n; j++)</div><div class="line">            matrix[0][j] = 0;</div><div class="line">    &#125;</div><div class="line">    if (col)&#123;</div><div class="line">        for(int i = 0; i &lt; m; i++)</div><div class="line">            matrix[i][0] = 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;quesiton&quot;&gt;Quesiton&lt;/h3&gt;
&lt;p&gt;Given a m x n matrix, if an element is 0, set its entir
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 200. Number of Islands</title>
    <link href="http://yoursite.com/2017/06/11/LeetCode-200-Number-of-Islands/"/>
    <id>http://yoursite.com/2017/06/11/LeetCode-200-Number-of-Islands/</id>
    <published>2017-06-11T21:14:11.000Z</published>
    <updated>2017-06-11T21:43:42.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><h3 id="question">Question</h3>
<p>Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>
<p>Example 1:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">11110</div><div class="line">11010</div><div class="line">11000</div><div class="line">00000</div></pre></td></tr></table></figure></p>
<p>Answer: 1</p>
<p>Example 2:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">11000</div><div class="line">11000</div><div class="line">00100</div><div class="line">00011</div></pre></td></tr></table></figure></p>
<p>Answer: 3</p>
<h3 id="explanation">Explanation</h3>
<p>运用BFS，找到一个1以后把周围的1标为‘0’。 从而确定island的个数。</p>
<h3 id="code">Code</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    //create a class as one point</div><div class="line">    class Coordinate&#123;</div><div class="line">        int x, y;</div><div class="line">        public Coordinate(int x, int y) &#123;</div><div class="line">            this.x = x;</div><div class="line">            this.y = y;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public int numIslands(char[][] grid) &#123;</div><div class="line">        if (grid == null || grid.length == 0 || grid[0].length == 0) &#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">        int n = grid.length;</div><div class="line">        int m = grid[0].length;</div><div class="line">        int islands = 0;</div><div class="line">        //find island from every &apos;1&apos;</div><div class="line">        for (int i=0; i&lt;n; i++) &#123;</div><div class="line">            for (int j =0; j &lt; m; j++) &#123;</div><div class="line">                if (grid[i][j] == &apos;1&apos;) &#123;</div><div class="line">                    markByBFS(grid, i, j);</div><div class="line">                    islands++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return islands;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    //mark the island around &apos;1&apos; as &apos;0&apos; to avoid duplications</div><div class="line">    private void markByBFS(char[][] grid,int x, int y) &#123;</div><div class="line">        //four directions, up, left, right, down</div><div class="line">        int[] directorX = &#123;0, 1, -1, 0&#125;;</div><div class="line">        int[] directorY = &#123;1, 0, 0, -1&#125;;</div><div class="line">        //using queue, BFS</div><div class="line">        Queue&lt;Coordinate&gt; queue = new LinkedList&lt;&gt;();</div><div class="line">        queue.offer(new Coordinate(x,y));</div><div class="line">        grid[x][y] = &apos;0&apos;;</div><div class="line">        while(!queue.isEmpty()) &#123;</div><div class="line">            Coordinate coor = queue.poll();</div><div class="line">            for(int i=0; i&lt;4; i++) &#123;</div><div class="line">                Coordinate adj = new Coordinate(</div><div class="line">                    coor.x + directorX[i],</div><div class="line">                    coor.y + directorY[i]</div><div class="line">                    );</div><div class="line">                //avoid for invalid point</div><div class="line">                if ( !inBound(adj, grid)) &#123;</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line">                if (grid[adj.x][adj.y] == &apos;1&apos;) &#123;</div><div class="line">                    grid[adj.x][adj.y] = &apos;0&apos;;</div><div class="line">                    queue.offer(adj);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private boolean inBound(Coordinate adj,char[][] grid) &#123;</div><div class="line">        int n = grid.length;</div><div class="line">        int m = grid[0].length;</div><div class="line">        return adj.x &gt;=0 &amp;&amp; adj.x &lt;n &amp;&amp;adj.y &gt;=0 &amp;&amp; adj.y&lt;m;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;question&quot;&gt;Question&lt;/h3&gt;
&lt;p&gt;Given a 2d grid map of &#39;1&#39;s (land) and &#39;0&#39;s (water), co
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="Union Field" scheme="http://yoursite.com/tags/Union-Field/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 210. Course Schedule II</title>
    <link href="http://yoursite.com/2017/06/10/LeetCode-210-Course-Schedule-II/"/>
    <id>http://yoursite.com/2017/06/10/LeetCode-210-Course-Schedule-II/</id>
    <published>2017-06-11T02:21:12.000Z</published>
    <updated>2017-06-11T02:24:22.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><h3 id="question">Question</h3>
<p>There are a total of n courses you have to take, labeled from 0 to n - 1.</p>
<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]</p>
<p>Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.</p>
<p>There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.</p>
<p>For example:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2, [[1,0]]</div></pre></td></tr></table></figure></p>
<p>There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1]
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">4, [[1,0],[2,0],[3,1],[3,2]]</div></pre></td></tr></table></figure></p>
<p>There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is[0,2,1,3].</p>
<p>Note:
The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.
You may assume that there are no duplicate edges in the input prerequisites.
click to show more hints.</p>
<p>Hints:
This problem is equivalent to finding the topological order in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses.
Topological Sort via DFS - A great video tutorial (21 minutes) on Coursera explaining the basic concepts of Topological Sort.
Topological sort could also be done via BFS.</p>
<h3 id="explanation">Explanation</h3>
<p>这道题是典型的可以用BFS的题，可以将这些关系考虑为一个graph。我们需要一个数据结构来存度数，用一个Queue来先存下没有先修课的课，然后按照度数来一次调出。得到最终的结构。</p>
<h3 id="code">Code</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public int[] findOrder(int numCourses, int[][] prerequisites) &#123;</div><div class="line">        HashMap&lt;Integer, Set&lt;Integer&gt;&gt; graph = new HashMap&lt;&gt;();</div><div class="line">        int[] indegree = new int[numCourses];</div><div class="line">        for (int i=0; i&lt;prerequisites.length; i++) indegree[prerequisites[i][0]]++;</div><div class="line">        int[] order = new int[numCourses];</div><div class="line">        int index = 0;</div><div class="line"></div><div class="line"></div><div class="line">        Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;();</div><div class="line">        for (int i=0; i&lt; numCourses; i++) &#123;</div><div class="line">            if (indegree[i] == 0) &#123;</div><div class="line">                order[index++] = i;</div><div class="line">                queue.offer(i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        while ( !queue.isEmpty()) &#123;</div><div class="line">            int prerequisite = queue.poll();</div><div class="line">            for (int i=0; i&lt;prerequisites.length; i++) &#123;</div><div class="line">                if (prerequisites[i][1] == prerequisite) &#123;</div><div class="line">                    indegree[prerequisites[i][0]] --;</div><div class="line">                    if(indegree[prerequisites[i][0]] == 0) &#123;</div><div class="line">                        order[index++] = prerequisites[i][0];</div><div class="line">                        queue.offer(prerequisites[i][0]);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return (index == numCourses) ? order : new int[0];</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;question&quot;&gt;Question&lt;/h3&gt;
&lt;p&gt;There are a total of n courses you have to take, labele
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 207. Course Schedule</title>
    <link href="http://yoursite.com/2017/06/10/LeetCode-207-Course-Schedule/"/>
    <id>http://yoursite.com/2017/06/10/LeetCode-207-Course-Schedule/</id>
    <published>2017-06-11T02:18:47.000Z</published>
    <updated>2017-06-11T02:26:56.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><h3 id="question">Question</h3>
<p>There are a total of n courses you have to take, labeled from 0 to n - 1.</p>
<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]</p>
<p>Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?</p>
<p>For example:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2, [[1,0]]</div></pre></td></tr></table></figure></p>
<p>There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2, [[1,0],[0,1]]</div></pre></td></tr></table></figure></p>
<p>There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.</p>
<p>Note:
The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.
You may assume that there are no duplicate edges in the input prerequisites.
click to show more hints.</p>
<p>Hints:
This problem is equivalent to finding if a cycle exists in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses.
Topological Sort via DFS - A great video tutorial (21 minutes) on Coursera explaining the basic concepts of Topological Sort.
Topological sort could also be done via BFS.</p>
<h3 id="explanation">Explanation</h3>
<p>这道题只要看可不可能，那么我们只要将graph理清楚，找到每个先修课的个数，依次放入队列就好了。</p>
<h3 id="code">Code</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public class Solution &#123;</div><div class="line">    public boolean canFinish(int numCourses, int[][] prerequisites) &#123;</div><div class="line">        int[][] matrix = new int[numCourses][numCourses];</div><div class="line">        int[] degree = new int[numCourses];</div><div class="line">        for (int i=0; i&lt; prerequisites.length; i++) &#123;</div><div class="line">            int ready = prerequisites[i][0];</div><div class="line">            int pre = prerequisites[i][1];</div><div class="line">            if (matrix[pre][ready] == 0) &#123;</div><div class="line">                degree[ready] ++;</div><div class="line">            &#125;</div><div class="line">            matrix[pre][ready] = 1;</div><div class="line">        &#125;</div><div class="line">        int count = 0;</div><div class="line">        Queue&lt;Integer&gt; queue = new LinkedList();</div><div class="line">        for (int i=0; i&lt; degree.length; i++) &#123;</div><div class="line">            if(degree[i] == 0) queue.offer(i);</div><div class="line">        &#125;</div><div class="line">        while (!queue.isEmpty()) &#123;</div><div class="line">            int course = queue.poll();</div><div class="line">            count ++;</div><div class="line">            for (int i=0; i&lt;numCourses;i++) &#123;</div><div class="line">                if (matrix[course][i] != 0) &#123;</div><div class="line">                    if (--degree[i] == 0) &#123;</div><div class="line">                        queue.offer(i);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return count ==numCourses;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;question&quot;&gt;Question&lt;/h3&gt;
&lt;p&gt;There are a total of n courses you have to take, labele
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络原理知识点初整理</title>
    <link href="http://yoursite.com/2017/06/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%9F%A5%E8%AF%86%E7%82%B9%E5%88%9D%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2017/06/07/计算机网络原理知识点初整理/</id>
    <published>2017-06-07T14:57:55.000Z</published>
    <updated>2017-06-11T02:18:11.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><p>更新中...</p>
<h2 id="http">HTTP</h2>
<h3 id="http报文">HTTP报文</h3>
<p>分为request line, header line, message body
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;method&gt; &lt;request-URL&gt; &lt;version&gt;</div><div class="line">&lt;headers&gt;</div><div class="line"></div><div class="line">&lt;entity-body&gt;</div></pre></td></tr></table></figure></p>
<h3 id="http基本方法">HTTP基本方法：</h3>
<p>GET，POST，PUT，DELETE。
URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源。</p>
<h4 id="get">GET：</h4>
<p>用于信息获取，而且应该是安全的 和 幂等的。</p>
<p>所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。</p>
<p>幂等的意味着对同一URL的多个请求应该返回同样的结果。</p>
<p>GET请求报文示例：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">GET /books/?sex=man&amp;name=Professional HTTP/1.1</div><div class="line"> Host: www.example.com</div><div class="line"> User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)</div><div class="line"> Gecko/20050225 Firefox/1.0.1</div><div class="line"> Connection: Keep-Alive</div></pre></td></tr></table></figure></p>
<h4 id="post">Post:</h4>
<p>报文示例：</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">POST / HTTP/1.1</div><div class="line">Host: www.example.com</div><div class="line">User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)</div><div class="line">Gecko/20050225 Firefox/1.0.1</div><div class="line">Content-Type: application/x-www-form-urlencoded</div><div class="line">Content-Length: 40</div><div class="line">Connection: Keep-Alive</div><div class="line"></div><div class="line">sex=man&amp;name=Professional</div></pre></td></tr></table></figure></p>
<p>HTTP 协议中规定 POST 提交的数据必须在 body 部分中，但是协议中没有规定数据使用哪种编码方式或者数据格式。实际上，开发者完全可以自己决定消息主体的格式，只要最后发送的 HTTP 请求满足上面的格式就可以。</p>
<h5 id="post提交数据的方式">Post提交数据的方式：</h5>
<h6 id="applicationx-www-form-urlencoded">application/x-www-form-urlencoded</h6>
<p>浏览器的原生 &lt;form&gt; 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。</p>
<h6 id="multipartform-data">multipart/form-data</h6>
<h3 id="响应报文">响应报文</h3>
<p>HTTP 响应与 HTTP 请求相似，HTTP响应也由3个部分构成，分别是：</p>
<p>状态行
响应头(Response Header)
响应正文</p>
<h3 id="常见状态码">常见状态码：</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">200 OK 客户端请求成功</div><div class="line">301 Moved Permanently 请求永久重定向</div><div class="line">302 Moved Temporarily 请求临时重定向</div><div class="line">304 Not Modified 文件未修改，可以直接使用缓存的文件。</div><div class="line">400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。</div><div class="line">401 Unauthorized 请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用</div><div class="line">403 Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因</div><div class="line">404 Not Found 请求的资源不存在，例如，输入了错误的URL</div><div class="line">500 Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。</div><div class="line">503 Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。</div></pre></td></tr></table></figure></p>
<h3 id="keep-alive">Keep-alive:</h3>
<p>在 HTTP 1.1 版本中，默认情况下所有连接都被保持，如果加入 &quot;Connection: close&quot; 才关闭。目前大部分浏览器都使用 HTTP 1.1 协议，也就是说默认都会发起 Keep-Alive 的连接请求了，所以是否能完成一个完整的 Keep-Alive 连接就看服务器设置情况。</p>
<p>使用长连接之后，客户端、服务端怎么知道本次传输结束呢？两部分：1. 判断传输数据是否达到了Content-Length 指示的大小；2. 动态生成的文件没有 Content-Length ，它是分块传输（chunked），这时候就要根据 chunked 编码来判断，chunked 编码的数据在最后有一个空 chunked 块，表明本次传输数据结束。</p>
<h3 id="cookie">Cookie</h3>
<p>Cookie是Web服务器发送给客户端的一小段信息，客户端请求时可以读取该信息发送到服务器端，进而进行用户的识别。对于客户端的每次请求，服务器都会将Cookie发送到客户端,在客户端可以进行保存,以便下次使用。</p>
<p>客户端可以采用两种方式来保存这个Cookie对象，一种方式是保存在客户端内存中，称为临时Cookie，浏览器关闭后这个Cookie对象将消失。另外一种方式是保存在客户机的磁盘上，称为永久Cookie。以后客户端只要访问该网站，就会将这个Cookie再次发送到服务器上，前提是这个Cookie在有效期内，这样就实现了对客户的跟踪。</p>
<p>Cookie是可以被禁止的。</p>
<h3 id="session">Session</h3>
<p>每一个用户都有一个不同的session，各个用户之间是不能共享的，是每个用户所独享的，在session中可以存放信息。</p>
<p>在服务器端会创建一个session对象，产生一个sessionID来标识这个session对象，然后将这个sessionID放入到Cookie中发送到客户端，下一次访问时，sessionID会发送到服务器，在服务器端进行识别不同的用户。</p>
<p>Session的实现依赖于Cookie，如果Cookie被禁用，那么session也将失效。</p>
<h3 id="token">Token</h3>
<p>目前主流的做法是使用 Token 抵御 CSRF 攻击。</p>
<p>Token 使用原则</p>
<ul>
<li>要足够随机————只有这样才算不可预测</li>
<li>是一次性的，即每次请求成功后要更新Token————这样可以增加攻击难度，增加预测难度</li>
<li>要注意保密性————敏感操作使用 post，防止 Token 出现在 URL 中</li>
</ul>
<p>注意：过滤用户输入的内容不能阻挡 csrf，我们需要做的是过滤请求的来源</p>
<h2 id="tcp">TCP</h2>
<ul>
<li>TCP提供一种面向连接的、可靠的字节流服务</li>
<li>在一个TCP连接中，仅有两方进行彼此通信。广播和多播不能用于TCP</li>
<li>TCP使用校验和，确认和重传机制来保证可靠传输</li>
<li>TCP给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复</li>
<li>TCP使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制</li>
</ul>
<h3 id="三次握手-three-way-handshake">三次握手 Three-way Handshake</h3>
<p>是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。
三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 connect() 时。将触发三次握手。
<img src="http://i.imgur.com/DROOpLM.png" alt="">
在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。
第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；</p>
<p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 完成三次握手，客户端与服务器开始传送数据.</p>
<h2 id="socket">Socket</h2>
<p>Socket 是对 TCP/IP 协议族的一种封装，是应用层与TCP/IP协议族通信的中间软件抽象层。从设计模式的角度看来，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。
Socket 还可以认为是一种网络间不同计算机上的进程通信的一种方法，利用三元组（ip地址，协议，端口）就可以唯一标识网络中的进程，网络中的进程通信可以利用这个标志与其它进程进行交互。</p>
<p><img src="http://i.imgur.com/w4tZUCs.png" alt=""></p>
<p>References:
https://hit-alibaba.github.io/interview/basic/network/HTTP.html</p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;更新中...&lt;/p&gt;
&lt;h2 id=&quot;http&quot;&gt;HTTP&lt;/h2&gt;
&lt;h3 id=&quot;http报文&quot;&gt;HTTP报文&lt;/h3&gt;
&lt;p&gt;分为request line, heade
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 261. Graph Valid Tree</title>
    <link href="http://yoursite.com/2017/06/05/LeetCode-261-Graph-Valid-Tree/"/>
    <id>http://yoursite.com/2017/06/05/LeetCode-261-Graph-Valid-Tree/</id>
    <published>2017-06-05T21:35:28.000Z</published>
    <updated>2017-06-05T22:02:31.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><h3 id="question">Question</h3>
<p>Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.</p>
<p>For example:</p>
<p>Given n = 5 and edges = [[0, 1], [0, 2], [0, 3], [1, 4]], return true.</p>
<p>Given n = 5 and edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]], return false.</p>
<p>Note: you can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.</p>
<h3 id="explanation">Explanation</h3>
<p>构造图的时候，用Hashmap这个数据结构存邻居。之后再去遍历邻居。图是树的条件有两个：1. 有n-1条边。2. 每个点都能联通。</p>
<h3 id="code">Code</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public boolean validTree(int n, int[][] edges) &#123;</div><div class="line">        // Condition 1: n-1 edges</div><div class="line">        // Condition 2: n个点联通</div><div class="line"></div><div class="line">        if (edges == null) return false;</div><div class="line">        if (edges.length != n-1 ) return false;</div><div class="line">        HashMap&lt;Integer, Set&lt;Integer&gt;&gt; graph = initialGraph (n,edges);</div><div class="line">        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();</div><div class="line">        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();</div><div class="line">        // bfs</div><div class="line">        queue.offer(0);</div><div class="line">        set.add(0);</div><div class="line">        while (!queue.isEmpty()) &#123;</div><div class="line">            int node = queue.poll();</div><div class="line">            for(Integer neighbour:graph.get(node)) &#123;</div><div class="line">                if (set.contains(neighbour)) &#123;</div><div class="line">                    continue;</div><div class="line">                &#125; else &#123;</div><div class="line">                    set.add(neighbour);</div><div class="line">                    queue.offer(neighbour);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return set.size() == n;</div><div class="line"></div><div class="line">  </div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public HashMap&lt;Integer, Set&lt;Integer&gt;&gt; initialGraph (int n, int[][] edges) &#123;</div><div class="line">        HashMap&lt;Integer, Set&lt;Integer&gt;&gt; graph = new HashMap&lt;&gt;();</div><div class="line">        for (int i=0; i&lt;n; i++) &#123;</div><div class="line">            Set&lt;Integer&gt; set = new HashSet&lt;&gt;();</div><div class="line">            graph.put(i, set);</div><div class="line">        &#125;</div><div class="line">        for (int i=0; i&lt;edges.length; i++) &#123;</div><div class="line">            int u = edges[i][0];</div><div class="line">            int v = edges[i][1];</div><div class="line">            graph.get(u).add(v);</div><div class="line">            graph.get(v).add(u);</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        return graph;</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;question&quot;&gt;Question&lt;/h3&gt;
&lt;p&gt;Given n nodes labeled from 0 to n - 1 and a list of und
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 102. Binary Tree Level Order Traversal</title>
    <link href="http://yoursite.com/2017/06/01/LeetCode-102-Binary-Tree-Level-Order-Traversal/"/>
    <id>http://yoursite.com/2017/06/01/LeetCode-102-Binary-Tree-Level-Order-Traversal/</id>
    <published>2017-06-01T18:29:46.000Z</published>
    <updated>2017-06-01T20:50:14.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><h3 id="question">Question</h3>
<p>Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).</p>
<p>For example:
Given binary tree [3,9,20,null,null,15,7],
3
/ <br>
9  20
/  <br>
15   7
return its level order traversal as:
[
[3],
[9,20],
[15,7]
]</p>
<h3 id="explanation">Explanation</h3>
<p>这是层级的遍历，就采用BFS即可。用Queue这个数据结构，注意每次递归时，用size来确定上层的节点个数。</p>
<h3 id="code">Code</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * public class TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode left;</div><div class="line"> *     TreeNode right;</div><div class="line"> *     TreeNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line">public class Solution &#123;</div><div class="line">    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</div><div class="line">        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();</div><div class="line">        List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();</div><div class="line">        if (root == null) return list;</div><div class="line">        queue.offer(root);</div><div class="line">        while(!queue.isEmpty()) &#123;</div><div class="line">            int size = queue.size();</div><div class="line">            List&lt;Integer&gt; level = new ArrayList&lt;&gt;();</div><div class="line">            for(int i=0; i&lt;size; i++) &#123;</div><div class="line">                TreeNode node = queue.poll();</div><div class="line">                level.add(node.val);</div><div class="line">                if (node.left != null) queue.offer(node.left);</div><div class="line">                if (node.right != null) queue.offer(node.right);</div><div class="line">            &#125;</div><div class="line">            list.add(level);</div><div class="line">        &#125;</div><div class="line">        return list;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;question&quot;&gt;Question&lt;/h3&gt;
&lt;p&gt;Given a binary tree, return the level order traversal o
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 501. Find Mode in Binary Search Tree</title>
    <link href="http://yoursite.com/2017/06/01/LeetCode-501-Find-Mode-in-Binary-Search-Tree/"/>
    <id>http://yoursite.com/2017/06/01/LeetCode-501-Find-Mode-in-Binary-Search-Tree/</id>
    <published>2017-06-01T15:55:11.000Z</published>
    <updated>2017-06-01T17:12:17.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><h3 id="question">Question</h3>
<p>Given a binary search tree (BST) with duplicates, find all the mode(s) (the most frequently occurred element) in the given BST.</p>
<p>Assume a BST is defined as follows:</p>
<p>The left subtree of a node contains only nodes with keys less than or equal to the node's key.
The right subtree of a node contains only nodes with keys greater than or equal to the node's key.
Both the left and right subtrees must also be binary search trees.
For example:
Given BST [1,null,2,2],
1
<br>
2
/
2
return [2].</p>
<h3 id="explanation">Explanation</h3>
<p>递归，注意要用全局变量保存之前的最大值，还有当前值。中序遍历整棵树，保存当前的值和count，如果和前面的值不同了，就重新计数。</p>
<h3 id="code">Code</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public class Solution &#123;</div><div class="line">    List&lt;Integer&gt; list;</div><div class="line">    int max;</div><div class="line">    int currval;</div><div class="line">    int currcount;</div><div class="line"></div><div class="line">    public int[] findMode(TreeNode root) &#123;</div><div class="line">        if(root == null) return new int[0];</div><div class="line">        currval =0;</div><div class="line">        currcount = 0;</div><div class="line">        helper(root);</div><div class="line">        int[] res = new int[list.size()];</div><div class="line">        for(int i = 0; i&lt;res.length; i++) res[i] = list.get(i);</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void helper(TreeNode root) &#123;</div><div class="line">        if (root == null) return;</div><div class="line">        helper(root.left);</div><div class="line">        if(root.val == currval) &#123;</div><div class="line">            currcount ++;</div><div class="line">        &#125; else &#123;</div><div class="line">            currcount = 1;</div><div class="line">            currval = root.val;</div><div class="line">        &#125;</div><div class="line">        if (currcount &gt; max) &#123;</div><div class="line">            max = currcount;</div><div class="line">            list = new ArrayList&lt;&gt;();</div><div class="line">            list.add(root.val);</div><div class="line">        &#125; else if(currcount == max) &#123;</div><div class="line">            list.add(root.val);</div><div class="line">        &#125;</div><div class="line">        helper(root.right);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;question&quot;&gt;Question&lt;/h3&gt;
&lt;p&gt;Given a binary search tree (BST) with duplicates, find 
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 109. Convert Sorted List to Binary Search Tree</title>
    <link href="http://yoursite.com/2017/05/31/LeetCode-109-Convert-Sorted-List-to-Binary-Search-Tree/"/>
    <id>http://yoursite.com/2017/05/31/LeetCode-109-Convert-Sorted-List-to-Binary-Search-Tree/</id>
    <published>2017-05-31T23:57:47.000Z</published>
    <updated>2017-05-31T23:59:29.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><h3 id="question">Question</h3>
<p>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</p>
<h3 id="explanation">Explanation</h3>
<p>和108题类似，唯一不同的是linkedinlist。用两个pointer找到中心点就好。</p>
<h3 id="code">Code</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">public TreeNode sortedListToBST(ListNode head) &#123;</div><div class="line">    if(head==null) return null;</div><div class="line">    return toBST(head,null);</div><div class="line">&#125;</div><div class="line">public TreeNode toBST(ListNode head, ListNode tail)&#123;</div><div class="line">    ListNode slow = head;</div><div class="line">    ListNode fast = head;</div><div class="line">    if(head==tail) return null;</div><div class="line"></div><div class="line">    while(fast!=tail&amp;&amp;fast.next!=tail)&#123;</div><div class="line">        fast = fast.next.next;</div><div class="line">        slow = slow.next;</div><div class="line">    &#125;</div><div class="line">    TreeNode thead = new TreeNode(slow.val);</div><div class="line">    thead.left = toBST(head,slow);</div><div class="line">    thead.right = toBST(slow.next,tail);</div><div class="line">    return thead;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;question&quot;&gt;Question&lt;/h3&gt;
&lt;p&gt;Given a singly linked list where elements are sorted in
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 108. Convert Sorted Array to Binary Search Tree</title>
    <link href="http://yoursite.com/2017/05/31/LeetCode-108-Convert-Sorted-Array-to-Binary-Search-Tree/"/>
    <id>http://yoursite.com/2017/05/31/LeetCode-108-Convert-Sorted-Array-to-Binary-Search-Tree/</id>
    <published>2017-05-31T23:42:53.000Z</published>
    <updated>2017-05-31T23:59:59.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><h3 id="question">Question</h3>
<p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p>
<h3 id="explanation">Explanation</h3>
<p>递归，每次找到根节点就行。</p>
<h3 id="code">Code</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * public class TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode left;</div><div class="line"> *     TreeNode right;</div><div class="line"> *     TreeNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line">public class Solution &#123;</div><div class="line"></div><div class="line">    public TreeNode sortedArrayToBST(int[] nums) &#123;</div><div class="line">        if (nums == null || nums.length == 0) return null;</div><div class="line">        return helper(nums, 0, nums.length-1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public TreeNode helper(int[] nums, int start, int end) &#123;</div><div class="line">        if (nums == null) return null;</div><div class="line">        //base case</div><div class="line">        if (start &gt; end) return null;</div><div class="line">        int mid = start + (end - start)/2;</div><div class="line">        TreeNode root = new TreeNode(nums[mid]);</div><div class="line">        root.left = helper(nums, start, mid-1);</div><div class="line">        root.right = helper(nums, mid+1, end);</div><div class="line">        return root;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;question&quot;&gt;Question&lt;/h3&gt;
&lt;p&gt;Given an array where elements are sorted in ascending o
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
  </entry>
  
</feed>
