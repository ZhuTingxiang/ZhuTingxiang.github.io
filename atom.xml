<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Star</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-05-31T23:59:29.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Star</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 109. Convert Sorted List to Binary Search Tree</title>
    <link href="http://yoursite.com/2017/05/31/LeetCode-109-Convert-Sorted-List-to-Binary-Search-Tree/"/>
    <id>http://yoursite.com/2017/05/31/LeetCode-109-Convert-Sorted-List-to-Binary-Search-Tree/</id>
    <published>2017-05-31T23:57:47.000Z</published>
    <updated>2017-05-31T23:59:29.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><h3 id="question">Question</h3>
<p>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</p>
<h3 id="explanation">Explanation</h3>
<p>和108题类似，唯一不同的是linkedinlist。用两个pointer找到中心点就好。</p>
<h3 id="code">Code</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">public TreeNode sortedListToBST(ListNode head) &#123;</div><div class="line">    if(head==null) return null;</div><div class="line">    return toBST(head,null);</div><div class="line">&#125;</div><div class="line">public TreeNode toBST(ListNode head, ListNode tail)&#123;</div><div class="line">    ListNode slow = head;</div><div class="line">    ListNode fast = head;</div><div class="line">    if(head==tail) return null;</div><div class="line"></div><div class="line">    while(fast!=tail&amp;&amp;fast.next!=tail)&#123;</div><div class="line">        fast = fast.next.next;</div><div class="line">        slow = slow.next;</div><div class="line">    &#125;</div><div class="line">    TreeNode thead = new TreeNode(slow.val);</div><div class="line">    thead.left = toBST(head,slow);</div><div class="line">    thead.right = toBST(slow.next,tail);</div><div class="line">    return thead;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;question&quot;&gt;Question&lt;/h3&gt;
&lt;p&gt;Given a singly linked list where elements are sorted in
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 108. Convert Sorted Array to Binary Search Tree</title>
    <link href="http://yoursite.com/2017/05/31/LeetCode-108-Convert-Sorted-Array-to-Binary-Search-Tree/"/>
    <id>http://yoursite.com/2017/05/31/LeetCode-108-Convert-Sorted-Array-to-Binary-Search-Tree/</id>
    <published>2017-05-31T23:42:53.000Z</published>
    <updated>2017-05-31T23:59:59.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><h3 id="question">Question</h3>
<p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p>
<h3 id="explanation">Explanation</h3>
<p>递归，每次找到根节点就行。</p>
<h3 id="code">Code</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * public class TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode left;</div><div class="line"> *     TreeNode right;</div><div class="line"> *     TreeNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line">public class Solution &#123;</div><div class="line"></div><div class="line">    public TreeNode sortedArrayToBST(int[] nums) &#123;</div><div class="line">        if (nums == null || nums.length == 0) return null;</div><div class="line">        return helper(nums, 0, nums.length-1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public TreeNode helper(int[] nums, int start, int end) &#123;</div><div class="line">        if (nums == null) return null;</div><div class="line">        //base case</div><div class="line">        if (start &gt; end) return null;</div><div class="line">        int mid = start + (end - start)/2;</div><div class="line">        TreeNode root = new TreeNode(nums[mid]);</div><div class="line">        root.left = helper(nums, start, mid-1);</div><div class="line">        root.right = helper(nums, mid+1, end);</div><div class="line">        return root;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;question&quot;&gt;Question&lt;/h3&gt;
&lt;p&gt;Given an array where elements are sorted in ascending o
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 173. Binary Search Tree Iterator</title>
    <link href="http://yoursite.com/2017/05/31/LeetCode-173-Binary-Search-Tree-Iterator/"/>
    <id>http://yoursite.com/2017/05/31/LeetCode-173-Binary-Search-Tree-Iterator/</id>
    <published>2017-05-31T23:16:22.000Z</published>
    <updated>2017-05-31T23:17:36.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><h3 id="question">Question</h3>
<p>Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.</p>
<p>Calling next() will return the next smallest number in the BST.</p>
<p>Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree</p>
<h3 id="explanation">Explanation</h3>
<p>完成中序遍历，用stack这个数据结构存储。</p>
<h3 id="code">Code</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/**</div><div class="line"> * Definition for binary tree</div><div class="line"> * public class TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode left;</div><div class="line"> *     TreeNode right;</div><div class="line"> *     TreeNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line"></div><div class="line">public class BSTIterator &#123;</div><div class="line">    Stack&lt;TreeNode&gt; stack;</div><div class="line"></div><div class="line">    public BSTIterator(TreeNode root) &#123;</div><div class="line">         stack = new Stack&lt;&gt;();</div><div class="line">         pushAllLeft(root);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void pushAllLeft(TreeNode node) &#123;</div><div class="line">        while(node != null) &#123;</div><div class="line">            stack.push(node);</div><div class="line">            node = node.left;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /** @return whether we have a next smallest number */</div><div class="line">    public boolean hasNext() &#123;</div><div class="line">        if(stack.isEmpty()) return false;</div><div class="line">        return true;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /** @return the next smallest number */</div><div class="line">    public int next() &#123;</div><div class="line">        TreeNode smallest = stack.pop();</div><div class="line">        pushAllLeft(smallest.right);</div><div class="line">        return smallest.val;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Your BSTIterator will be called like this:</div><div class="line"> * BSTIterator i = new BSTIterator(root);</div><div class="line"> * while (i.hasNext()) v[f()] = i.next();</div><div class="line"> */</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;question&quot;&gt;Question&lt;/h3&gt;
&lt;p&gt;Implement an iterator over a binary search tree (BST). 
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 98. Validate Binary Search Tree</title>
    <link href="http://yoursite.com/2017/05/31/LeetCode-98-Validate-Binary-Search-Tree/"/>
    <id>http://yoursite.com/2017/05/31/LeetCode-98-Validate-Binary-Search-Tree/</id>
    <published>2017-05-31T22:33:49.000Z</published>
    <updated>2017-05-31T22:37:03.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><h3 id="question">Question</h3>
<p>Given a binary tree, determine if it is a valid binary search tree (BST).</p>
<p>Assume a BST is defined as follows:</p>
<p>The left subtree of a node contains only nodes with keys less than the node's key.
The right subtree of a node contains only nodes with keys greater than the node's key.
Both the left and right subtrees must also be binary search trees.
Example 1:
2
/ <br>
1   3
Binary tree [2,1,3], return true.
Example 2:
1
/ <br>
2   3
Binary tree [1,2,3], return false.</p>
<h3 id="explanation">Explanation</h3>
<p>在递归中，除了和根节点比较大小之外，还要考虑到之前的根节点的大小，所以这里设置一个上下限。</p>
<h3 id="code">Code</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public class Solution &#123;</div><div class="line">    public boolean isValidBST(TreeNode root) &#123;</div><div class="line">        if (root == null) &#123;</div><div class="line">            return true;</div><div class="line">            &#125;</div><div class="line">            return dfs(root, Long.MIN_VALUE, Long.MAX_VALUE);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">     public boolean dfs(TreeNode root, long low, long up) &#123;</div><div class="line">         if (root == null) &#123;</div><div class="line">             return true;</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         if (root.val &gt;= up || root.val &lt;= low) &#123;</div><div class="line">           return false;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">      return dfs(root.left, low, root.val)</div><div class="line">            &amp;&amp; dfs(root.right, root.val, up);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;question&quot;&gt;Question&lt;/h3&gt;
&lt;p&gt;Given a binary tree, determine if it is a valid binary 
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 113.Path Sum II</title>
    <link href="http://yoursite.com/2017/05/31/LeetCode-113-Path-Sum-II/"/>
    <id>http://yoursite.com/2017/05/31/LeetCode-113-Path-Sum-II/</id>
    <published>2017-05-31T15:03:05.000Z</published>
    <updated>2017-05-31T15:04:37.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><h3 id="question">Question</h3>
<p>Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum.</p>
<p>For example:
Given the below binary tree and sum = 22,
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">      5</div><div class="line">     / \</div><div class="line">    4   8</div><div class="line">   /   / \</div><div class="line">  11  13  4</div><div class="line"> /  \    / \</div><div class="line">7    2  5   1</div></pre></td></tr></table></figure></p>
<p>return
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">   [5,4,11,2],</div><div class="line">   [5,8,4,5]</div><div class="line">]</div></pre></td></tr></table></figure></p>
<h3 id="explanation">Explanation</h3>
<p>递归的时候保留路径，满足就存入全局变量中。</p>
<h3 id="code">Code</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * public class TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode left;</div><div class="line"> *     TreeNode right;</div><div class="line"> *     TreeNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line">public class Solution &#123;</div><div class="line">    private List&lt;List&lt;Integer&gt;&gt; resultList = new ArrayList&lt;List&lt;Integer&gt;&gt;();</div><div class="line"></div><div class="line"></div><div class="line">    public void pathSumHelper(TreeNode root, int sum, ArrayList&lt;Integer&gt; path)&#123;</div><div class="line">        path.add(root.val);</div><div class="line">        if (root == null) return;</div><div class="line">        if (root.left == null &amp;&amp; root.right == null) &#123;</div><div class="line">            if (root.val== sum) &#123;</div><div class="line">                resultList.add(new ArrayList&lt;Integer&gt;(path));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (root.left != null) pathSumHelper(root.left, sum - root.val, path);</div><div class="line">        if (root.right != null) pathSumHelper(root.right, sum - root.val, path);</div><div class="line">        path.remove(path.size()-1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123;</div><div class="line">        if(root==null) return resultList;</div><div class="line">        ArrayList&lt;Integer&gt; path = new ArrayList&lt;&gt;();</div><div class="line">        pathSumHelper(root, sum, path);</div><div class="line">        return resultList;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;question&quot;&gt;Question&lt;/h3&gt;
&lt;p&gt;Given a binary tree and a sum, find all root-to-leaf pa
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 112.Path Sum</title>
    <link href="http://yoursite.com/2017/05/30/LeetCode-112-Path-Sum/"/>
    <id>http://yoursite.com/2017/05/30/LeetCode-112-Path-Sum/</id>
    <published>2017-05-30T22:33:37.000Z</published>
    <updated>2017-05-31T15:04:32.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><h3 id="question">Question</h3>
<p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p>
<p>For example:
Given the below binary tree and sum = 22,
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">      5</div><div class="line">     / \</div><div class="line">    4   8</div><div class="line">   /   / \</div><div class="line">  11  13  4</div><div class="line"> /  \      \</div><div class="line">7    2      1</div></pre></td></tr></table></figure></p>
<p>return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22.</p>
<h3 id="explanation">Explanation</h3>
<p>简单的递归分治法。</p>
<h3 id="code">Code</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * public class TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode left;</div><div class="line"> *     TreeNode right;</div><div class="line"> *     TreeNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line">public class Solution &#123;</div><div class="line">    public boolean hasPathSum(TreeNode root, int sum) &#123;</div><div class="line">        if (root == null) return false;</div><div class="line">        if (root.right == null &amp;&amp; root.left == null)&#123;</div><div class="line">            if(root.val == sum) return true;</div><div class="line">        &#125;</div><div class="line">        return hasPathSum(root.left, sum-root.val) || hasPathSum(root.right, sum-root.val);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;question&quot;&gt;Question&lt;/h3&gt;
&lt;p&gt;Given a binary tree and a sum, determine if the tree ha
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 236.Lowest Common Ancestor of a Binary  Tree</title>
    <link href="http://yoursite.com/2017/05/30/LeetCode-236-Lowest-Common-Ancestor-of-a-Binary-Tree/"/>
    <id>http://yoursite.com/2017/05/30/LeetCode-236-Lowest-Common-Ancestor-of-a-Binary-Tree/</id>
    <published>2017-05-30T20:56:42.000Z</published>
    <updated>2017-05-30T20:58:48.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><h3 id="question">Question</h3>
<p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>
<p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">     _______3______</div><div class="line">    /              \</div><div class="line"> ___5__          ___1__</div><div class="line">/      \        /      \</div><div class="line">6      _2       0       8</div><div class="line">      /  \</div><div class="line">      7   4</div></pre></td></tr></table></figure></p>
<p>For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3. Another example is LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.</p>
<h3 id="explanation">Explanation</h3>
<p>二叉树分治递归。找AB时，如果根节点是其中一个，返回根。如果左边找到一个，右边找到一个，返回根。</p>
<h3 id="code">Code</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * public class TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode left;</div><div class="line"> *     TreeNode right;</div><div class="line"> *     TreeNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line">public class Solution &#123;</div><div class="line">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</div><div class="line">        if (root == null || root == p || root == q) return root;</div><div class="line">        TreeNode left = lowestCommonAncestor(root.left, p, q);</div><div class="line">        TreeNode right = lowestCommonAncestor(root.right, p, q);</div><div class="line">        if (left != null &amp;&amp; right != null) return root;</div><div class="line">        if (left != null) return left;</div><div class="line">        if (right != null) return right;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;question&quot;&gt;Question&lt;/h3&gt;
&lt;p&gt;Given a binary tree, find the lowest common ancestor (L
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 235.Lowest Common Ancestor of a Binary Search Tree</title>
    <link href="http://yoursite.com/2017/05/30/LeetCode-235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree/"/>
    <id>http://yoursite.com/2017/05/30/LeetCode-235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree/</id>
    <published>2017-05-30T20:50:41.000Z</published>
    <updated>2017-05-30T20:56:30.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><h3 id="question">Question</h3>
<p>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.</p>
<p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">     _______6______</div><div class="line">    /              \</div><div class="line"> ___2__          ___8__</div><div class="line">/      \        /      \</div><div class="line">0      _4       7       9</div><div class="line">      /  \</div><div class="line">      3   5</div></pre></td></tr></table></figure></p>
<p>For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.</p>
<h3 id="explanation">Explanation</h3>
<p>既然是二叉搜索树，那就可以根据值来进行判断。分治递归。</p>
<h3 id="code">Code</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * public class TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode left;</div><div class="line"> *     TreeNode right;</div><div class="line"> *     TreeNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line"></div><div class="line"></div><div class="line">public class Solution &#123;</div><div class="line">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</div><div class="line">       if (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) return lowestCommonAncestor(root.left, p,q);</div><div class="line">       if (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) return lowestCommonAncestor(root.right, p,q);</div><div class="line">       return root;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;question&quot;&gt;Question&lt;/h3&gt;
&lt;p&gt;Given a binary search tree (BST), find the lowest commo
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
      <category term="Binary Search Tree" scheme="http://yoursite.com/tags/Binary-Search-Tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 114. Flatten Binary Tree to Linked List</title>
    <link href="http://yoursite.com/2017/05/30/LeetCode-114-Flatten-Binary-Tree-to-Linked-List/"/>
    <id>http://yoursite.com/2017/05/30/LeetCode-114-Flatten-Binary-Tree-to-Linked-List/</id>
    <published>2017-05-30T19:56:40.000Z</published>
    <updated>2017-05-30T19:58:54.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><h3 id="question">Question</h3>
<p>Given a binary tree, flatten it to a linked list in-place.</p>
<p>For example,
Given
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">    1</div><div class="line">   / \</div><div class="line">  2   5</div><div class="line"> / \   \</div><div class="line">3   4   6</div></pre></td></tr></table></figure></p>
<p>The flattened tree should look like:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line"> \</div><div class="line">  2</div><div class="line">   \</div><div class="line">    3</div><div class="line">     \</div><div class="line">      4</div><div class="line">       \</div><div class="line">        5</div><div class="line">         \</div><div class="line">          6</div></pre></td></tr></table></figure></p>
<h3 id="explanation">Explanation</h3>
<p>分治法，左右子树递归以后，把左右根节点依次排到右边，左边为空即可。</p>
<h3 id="code">Code</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * public class TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode left;</div><div class="line"> *     TreeNode right;</div><div class="line"> *     TreeNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line">public class Solution &#123;</div><div class="line"></div><div class="line">    public void flatten(TreeNode root) &#123;</div><div class="line">        if (root == null) return;</div><div class="line">        TreeNode right = root.right;</div><div class="line">        TreeNode left = root.left;</div><div class="line">        flatten(right);</div><div class="line">        flatten(left);</div><div class="line">        root.left = null;</div><div class="line">        root.right = left;</div><div class="line">        TreeNode cur = root;</div><div class="line">        while(cur.right != null) cur = cur.right;</div><div class="line">        cur.right = right;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;question&quot;&gt;Question&lt;/h3&gt;
&lt;p&gt;Given a binary tree, flatten it to a linked list in-pla
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 110. Balanced Binary Tree</title>
    <link href="http://yoursite.com/2017/05/30/LeetCode-110-Balanced-Binary-Tree/"/>
    <id>http://yoursite.com/2017/05/30/LeetCode-110-Balanced-Binary-Tree/</id>
    <published>2017-05-30T19:14:57.000Z</published>
    <updated>2017-05-30T19:56:59.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><h3 id="question">Question</h3>
<p>Given a binary tree, determine if it is height-balanced.</p>
<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p>
<h3 id="explanation">Explanation</h3>
<p>在这里还是用递归，判断条件为1. 左右子树均balance 2.左右子树高度只差不超过1. 所以在这道题中，为了能返回两个值，就创建了一个新的类：ResultType。如果用python写就不用了。</p>
<h3 id="code">Code</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * public class TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode left;</div><div class="line"> *     TreeNode right;</div><div class="line"> *     TreeNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line"></div><div class="line">class ResultType &#123;</div><div class="line">    public boolean isBalanced;</div><div class="line">    public int maxDepth;</div><div class="line">    public ResultType(boolean isBalanced, int maxDepth) &#123;</div><div class="line">        this.isBalanced = isBalanced;</div><div class="line">        this.maxDepth = maxDepth;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Solution &#123;</div><div class="line">    public boolean isBalanced(TreeNode root) &#123;</div><div class="line">        if (root == null) return true;</div><div class="line">        return helper(root).isBalanced;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public ResultType helper(TreeNode root) &#123;</div><div class="line">        if (root == null ) return new ResultType(true, 0);</div><div class="line">        ResultType left = helper(root.left);</div><div class="line">        ResultType right = helper(root.right);</div><div class="line">        if (left.isBalanced &amp;&amp; right.isBalanced &amp;&amp; Math.abs(left.maxDepth-right.maxDepth)&lt;=1)  &#123;</div><div class="line">            return new ResultType(true, Math.max(left.maxDepth,right.maxDepth)+1);</div><div class="line">        &#125;</div><div class="line">        return new ResultType(false, -1);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;question&quot;&gt;Question&lt;/h3&gt;
&lt;p&gt;Given a binary tree, determine if it is height-balanced
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title>LintCode 596. Minimum Subtree</title>
    <link href="http://yoursite.com/2017/05/30/LintCode-596-Minimum-Subtree/"/>
    <id>http://yoursite.com/2017/05/30/LintCode-596-Minimum-Subtree/</id>
    <published>2017-05-30T17:40:53.000Z</published>
    <updated>2017-05-30T18:19:08.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><h3 id="question">Question</h3>
<p>Description
Given a binary tree, find the subtree with minimum sum. Return the root of the subtree.</p>
<p>Notice
LintCode will print the subtree which root is your return node.
It's guaranteed that there is only one subtree with minimum sum and the given binary tree is not an empty tree.</p>
<p>Example
Given a binary tree:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">      1</div><div class="line">    /   \</div><div class="line"> -5      2</div><div class="line"> / \     /  \</div><div class="line">0   2   -4  -5</div></pre></td></tr></table></figure></p>
<p>return the node 1.</p>
<h3 id="explanation">Explanation</h3>
<p>可以用遍历的方式来递归，也可以用分治法。分治法的话要注意自己构造一个类。</p>
<h3 id="code">Code</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">// version 1 : traverse + divide conquer</div><div class="line">public class Solution &#123;</div><div class="line">    private TreeNode subtree = null;</div><div class="line">    private int subtreeSum = Integer.MAX_VALUE;</div><div class="line">    /**</div><div class="line">     * @param root the root of binary tree</div><div class="line">     * @return the root of the minimum subtree</div><div class="line">     */</div><div class="line">    public TreeNode findSubtree(TreeNode root) &#123;</div><div class="line">        helper(root);</div><div class="line">        return subtree;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private int helper(TreeNode root) &#123;</div><div class="line">        if (root == null) &#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        int sum = helper(root.left) + helper(root.right) + root.val;</div><div class="line">        if (sum &lt; subtreeSum) &#123;</div><div class="line">            subtreeSum = sum;</div><div class="line">            subtree = root;</div><div class="line">        &#125;</div><div class="line">        return sum;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// version 2: Pure divide conquer</div><div class="line">class ResultType &#123;</div><div class="line">    public TreeNode minSubtree;</div><div class="line">    public int sum, minSum;</div><div class="line">    public ResultType(TreeNode minSubtree, int minSum, int sum) &#123;</div><div class="line">        this.minSubtree = minSubtree;</div><div class="line">        this.minSum = minSum;</div><div class="line">        this.sum = sum;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">public class Solution &#123;</div><div class="line">    /**</div><div class="line">     * @param root the root of binary tree</div><div class="line">     * @return the root of the minimum subtree</div><div class="line">     */</div><div class="line">    public TreeNode findSubtree(TreeNode root) &#123;</div><div class="line">        ResultType result = helper(root);</div><div class="line">        return result.minSubtree;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public ResultType helper(TreeNode node) &#123;</div><div class="line">        if (node == null) &#123;</div><div class="line">            return new ResultType(null, Integer.MAX_VALUE, 0);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ResultType leftResult = helper(node.left);</div><div class="line">        ResultType rightResult = helper(node.right);</div><div class="line"></div><div class="line">        ResultType result = new ResultType(</div><div class="line">            node,</div><div class="line">            leftResult.sum + rightResult.sum + node.val,</div><div class="line">            leftResult.sum + rightResult.sum + node.val</div><div class="line">        );</div><div class="line"></div><div class="line">        if (leftResult.minSum &lt; result.minSum) &#123;</div><div class="line">            result.minSum = leftResult.minSum;</div><div class="line">            result.minSubtree = leftResult.minSubtree;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (rightResult.minSum &lt; result.minSum) &#123;</div><div class="line">            result.minSum = rightResult.minSum;</div><div class="line">            result.minSubtree = rightResult.minSubtree;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;question&quot;&gt;Question&lt;/h3&gt;
&lt;p&gt;Description
Given a binary tree, find the subtree with 
    
    </summary>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 257. Binary Tree Path</title>
    <link href="http://yoursite.com/2017/05/30/Leetcode-257-Binary-Tree-Path/"/>
    <id>http://yoursite.com/2017/05/30/Leetcode-257-Binary-Tree-Path/</id>
    <published>2017-05-30T16:59:43.000Z</published>
    <updated>2017-05-30T17:02:18.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><h3 id="question">Question</h3>
<p>Given a binary tree, return all root-to-leaf paths.</p>
<p>For example, given the following binary tree:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">   1</div><div class="line"> /   \</div><div class="line">2     3</div><div class="line"> \</div><div class="line">  5</div></pre></td></tr></table></figure></p>
<p>All root-to-leaf paths are:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]</div></pre></td></tr></table></figure></p>
<h3 id="explanation">Explanation</h3>
<p>分治法，只用考虑左右子树会出现的情况就好了。另外此处注意叶子节点，就不用加“-&gt;”了。</p>
<h3 id="code">Code</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;</div><div class="line">        List&lt;String&gt; result = new ArrayList&lt;&gt;();</div><div class="line">        if (root == null) return result;</div><div class="line">        if (root.left == null &amp;&amp; root.right == null) result.add(Integer.toString(root.val));</div><div class="line">        List&lt;String&gt; left = binaryTreePaths(root.left);</div><div class="line">        List&lt;String&gt; right = binaryTreePaths(root.right);</div><div class="line">        for(String s:left) &#123;</div><div class="line">            result.add(root.val+&quot;-&gt;&quot;+s);</div><div class="line">        &#125;</div><div class="line">        for(String s: right) &#123;</div><div class="line">            result.add(root.val + &quot;-&gt;&quot; + s);</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;question&quot;&gt;Question&lt;/h3&gt;
&lt;p&gt;Given a binary tree, return all root-to-leaf paths.&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 104. Binary Tree Postorder Traversal</title>
    <link href="http://yoursite.com/2017/05/30/Leetcode-104-Maximum-Depth-of-Binary-Tree/"/>
    <id>http://yoursite.com/2017/05/30/Leetcode-104-Maximum-Depth-of-Binary-Tree/</id>
    <published>2017-05-30T16:51:04.000Z</published>
    <updated>2017-05-30T16:58:26.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><h3 id="question">Question</h3>
<p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<h3 id="explanation">Explanation</h3>
<p>分治法递归，非常简单。</p>
<h3 id="code">Code</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public int maxDepth(TreeNode root) &#123;</div><div class="line">        if (root == null) return 0;</div><div class="line">        int maxLeft = maxDepth(root.left);</div><div class="line">        int maxRight = maxDepth(root.right);</div><div class="line">        return Math.max(maxLeft, maxRight)+1;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;question&quot;&gt;Question&lt;/h3&gt;
&lt;p&gt;Given a binary tree, find its maximum depth.&lt;/p&gt;
&lt;p&gt;The
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 145. Binary Tree Postorder Traversal</title>
    <link href="http://yoursite.com/2017/05/30/Leetcode-145-Binary-Tree-Postorder-Traversal/"/>
    <id>http://yoursite.com/2017/05/30/Leetcode-145-Binary-Tree-Postorder-Traversal/</id>
    <published>2017-05-30T16:30:44.000Z</published>
    <updated>2017-05-30T16:33:22.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><h3 id="question">Question</h3>
<p>Given a binary tree, return the postorder traversal of its nodes' values.</p>
<p>For example:
Given binary tree {1,#,2,3},
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line"> \</div><div class="line">  2</div><div class="line"> /</div><div class="line">3</div></pre></td></tr></table></figure></p>
<p>return [3,2,1].</p>
<h3 id="explanation">Explanation</h3>
<p>比之前做的preorder和inorder要难些，这里用了一个巧妙的办法，每次加在前面addfirst。如果不这样的话，就需要记录是否visit过了。</p>
<h3 id="code">Code</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    // Recursive Solution:</div><div class="line">    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;</div><div class="line">         List&lt;Integer&gt; result = new ArrayList&lt;&gt;();</div><div class="line">         if (root == null) return result;</div><div class="line">         List&lt;Integer&gt; left = postorderTraversal(root.left);</div><div class="line">         List&lt;Integer&gt; right = postorderTraversal(root.right);</div><div class="line"></div><div class="line"></div><div class="line">         result.addAll(left);</div><div class="line">         result.addAll(right);</div><div class="line">         result.add(root.val);</div><div class="line">         return result;</div><div class="line">    &#125;</div><div class="line">    // Iterative Solution:</div><div class="line">    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;</div><div class="line">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</div><div class="line">        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();</div><div class="line">        if (root == null) return result;</div><div class="line">        TreeNode tmp = root;</div><div class="line">        stack.push(root);</div><div class="line">        while (!stack.isEmpty()) &#123;</div><div class="line">            TreeNode cur = stack.pop();</div><div class="line">            result.addFirst(cur.val);</div><div class="line">            if (cur.left != null) &#123;</div><div class="line">                stack.push(cur.left);</div><div class="line">            &#125;</div><div class="line">            if (cur.right != null) &#123;</div><div class="line">                stack.push(cur.right);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;question&quot;&gt;Question&lt;/h3&gt;
&lt;p&gt;Given a binary tree, return the postorder traversal of 
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="Google" scheme="http://yoursite.com/tags/Google/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
      <category term="Hard" scheme="http://yoursite.com/tags/Hard/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 144. Binary Tree Preorder Traversal</title>
    <link href="http://yoursite.com/2017/05/30/Leetcode-144-Binary-Tree-Preorder-Traversal/"/>
    <id>http://yoursite.com/2017/05/30/Leetcode-144-Binary-Tree-Preorder-Traversal/</id>
    <published>2017-05-30T15:11:13.000Z</published>
    <updated>2017-05-30T15:14:02.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><h3 id="question">Question</h3>
<p>Given a binary tree, return the preorder traversal of its nodes' values.</p>
<p>For example:
Given binary tree {1,#,2,3},
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line"> \</div><div class="line">  2</div><div class="line"> /</div><div class="line">3</div></pre></td></tr></table></figure></p>
<p>return [1,2,3].</p>
<h3 id="explanation">Explanation</h3>
<p>依旧是两种方法，递归和遍历。递归非常容易，分治即可。遍历需要用到Stack这个数据结构，想清楚顺序就好。</p>
<h3 id="code">Code</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">     public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;</div><div class="line">         List&lt;Integer&gt; result = new ArrayList&lt;&gt;();</div><div class="line">         if (root == null) return result;</div><div class="line">         List&lt;Integer&gt; left = preorderTraversal(root.left);</div><div class="line">         List&lt;Integer&gt; right = preorderTraversal(root.right);</div><div class="line"></div><div class="line">         result.add(root.val);</div><div class="line">         result.addAll(left);</div><div class="line">         result.addAll(right);</div><div class="line">         return result;</div><div class="line">     &#125;</div><div class="line">    // Iterative solution</div><div class="line">    // public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;</div><div class="line">    //     Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</div><div class="line">    //     List&lt;Integer&gt; result = new ArrayList&lt;&gt;();</div><div class="line">    //     if (root == null) return result;</div><div class="line">    //     TreeNode tmp = root;</div><div class="line">    //     stack.add(root);</div><div class="line">    //     while (!stack.isEmpty()) &#123;</div><div class="line">    //         tmp = stack.pop();</div><div class="line">    //         result.add(tmp.val);</div><div class="line">    //         if (tmp.right != null) stack.push(tmp.right);</div><div class="line">    //         if (tmp.left != null) stack.push(tmp.left);</div><div class="line">    //     &#125;</div><div class="line">    //     return result;</div><div class="line">    //     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;question&quot;&gt;Question&lt;/h3&gt;
&lt;p&gt;Given a binary tree, return the preorder traversal of i
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="Google" scheme="http://yoursite.com/tags/Google/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 367. Valid Perfect Square</title>
    <link href="http://yoursite.com/2017/05/28/LeetCode-367-Valid-Perfect-Square/"/>
    <id>http://yoursite.com/2017/05/28/LeetCode-367-Valid-Perfect-Square/</id>
    <published>2017-05-28T21:54:18.000Z</published>
    <updated>2017-05-28T23:00:31.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><h3 id="question">Question</h3>
<p>Given a positive integer num, write a function which returns True if num is a perfect square else False.</p>
<p>Note: Do not use any built-in library function such as sqrt.</p>
<p>Example 1:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: 16</div><div class="line">Returns: True</div></pre></td></tr></table></figure></p>
<p>Example 2:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: 14</div><div class="line">Returns: False</div></pre></td></tr></table></figure></p>
<h3 id="explanation">Explanation</h3>
<p>本题是查找平方根。Corner Case排除负数。用二分法找到值，注意overflow的问题，不能用乘法，用除法。</p>
<h3 id="code">Code</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public boolean isPerfectSquare(int num) &#123;</div><div class="line">        if(num &lt;= 0) return false;</div><div class="line">        if (num == 1) return true;</div><div class="line">        int start = 0;</div><div class="line">        int end = num;</div><div class="line">        while (start + 1 &lt; end) &#123;</div><div class="line">            int mid = start + (end - start) / 2;</div><div class="line">            if (num / mid == mid) &#123;</div><div class="line">                start = mid;</div><div class="line">            &#125; else if (num / mid &lt; mid) &#123;</div><div class="line">                end = mid;</div><div class="line">            &#125; else &#123;</div><div class="line">                start = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if ( num*1.0 / start == start) return true;</div><div class="line">        if ( num*1.0 / end == end) return true;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;question&quot;&gt;Question&lt;/h3&gt;
&lt;p&gt;Given a positive integer num, write a function which re
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Binary Search 二分查找</title>
    <link href="http://yoursite.com/2017/05/28/Binary%20Search/"/>
    <id>http://yoursite.com/2017/05/28/Binary Search/</id>
    <published>2017-05-28T18:13:27.000Z</published>
    <updated>2017-05-30T14:26:30.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><h2 id="二分查找模板总结">二分查找模板总结</h2>
<p>四点要素：</p>
<ul>
<li>start + 1 &lt; end</li>
<li>start + (end - start) / 2</li>
<li>A[mid] ==, &lt;, &gt;</li>
<li>A[start] A[end] ? target</li>
</ul>
<p>二分法关键</p>
<ul>
<li>头尾指针，取中点，判断往哪儿走</li>
<li>寻找满足某个条件第一个或是最后一个位置</li>
<li>保留剩下来一定有解的那一半</li>
</ul>
<h3 id="question-1-classical-binary-search">Question 1: classical-binary-search</h3>
<p>https://www.lintcode.com/en/problem/classical-binary-search/</p>
<p>Find any position of a target number in a sorted array. Return -1 if target does not exist.</p>
<p>Given [1, 2, 2, 4, 5, 5].</p>
<p>For target = 2, return 1 or 2.</p>
<p>For target = 5, return 4 or 5.</p>
<p>For target = 6, return -1.</p>
<h3 id="explanation">Explanation</h3>
<p>基本的二分查找。</p>
<h3 id="code">Code</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    /**</div><div class="line">     * @param A an integer array sorted in ascending order</div><div class="line">     * @param target an integer</div><div class="line">     * @return an integer</div><div class="line">     */</div><div class="line">    public int findPosition(int[] A, int target) &#123;</div><div class="line">        // Write your code here</div><div class="line">        if (A == null || A.length == 0)&#123;</div><div class="line">            return -1;</div><div class="line">        &#125;</div><div class="line">        int start = 0;</div><div class="line">        int end = A.length - 1;</div><div class="line">        while (start + 1 &lt; end) &#123;</div><div class="line">            int mid = start + (end - start) / 2;</div><div class="line">            if (target == A[mid]) &#123;</div><div class="line">                end = mid;</div><div class="line">            &#125; else if (target &gt; A[mid]) &#123;</div><div class="line">                start = mid;</div><div class="line">            &#125; else &#123;</div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (target == A[start]) &#123;</div><div class="line">            return start;</div><div class="line">        &#125;</div><div class="line">        if (target == A[end]) &#123;</div><div class="line">            return end;</div><div class="line">        &#125;</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="question-2-first-position-of-target">Question 2: First Position of target</h3>
<p>For a given sorted array (ascending order) and a target number, find the first index of this number in O(log n) time complexity.</p>
<p>If the target number does not exist in the array, return -1.</p>
<p>If the array is [1, 2, 3, 3, 4, 5, 10], for given target 3, return 2.</p>
<h3 id="code">Code</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">    /**</div><div class="line">     * @param nums: The integer array.</div><div class="line">     * @param target: Target to find.</div><div class="line">     * @return: The first position of target. Position starts from 0.</div><div class="line">     */</div><div class="line">    public int binarySearch(int[] nums, int target) &#123;</div><div class="line">        //write your code here</div><div class="line">        if (nums == null || nums.length == 0) return -1;</div><div class="line">        int start = 0;</div><div class="line">        int end = nums.length - 1;</div><div class="line">        while (start + 1 &lt; end) &#123;</div><div class="line">            int mid = start + (end - start) / 2;</div><div class="line">            if (target == nums[mid]) &#123;</div><div class="line">                end = mid;</div><div class="line">            &#125; else if (target &gt; nums[mid]) &#123;</div><div class="line">                start = mid;</div><div class="line">            &#125; else &#123;</div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (target == nums[start]) return start;</div><div class="line">        if (target == nums[end]) return end;</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="question-3-last-position-of-target">Question 3: last-position-of-target</h3>
<p>给一个升序数组，找到target最后一次出现的位置，如果没出现过返回-1</p>
<h3 id="code">Code</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    /**</div><div class="line">     * @param A an integer array sorted in ascending order</div><div class="line">     * @param target an integer</div><div class="line">     * @return an integer</div><div class="line">     */</div><div class="line">    public int lastPosition(int[] A, int target) &#123;</div><div class="line">        // Write your code here</div><div class="line">        if (A == null || A.length == 0)&#123;</div><div class="line">            return -1;</div><div class="line">        &#125;</div><div class="line">        int start = 0;</div><div class="line">        int end = A.length - 1;</div><div class="line">        while (start + 1 &lt; end) &#123;</div><div class="line">            int mid = start + (end - start) / 2;</div><div class="line">            if (target == A[mid]) &#123;</div><div class="line">                //difference with the above questions</div><div class="line">                start = mid;</div><div class="line">            &#125; else if (target &gt; A[mid]) &#123;</div><div class="line">                start = mid;</div><div class="line">            &#125; else &#123;</div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //check end element first</div><div class="line">        if (target == A[end]) &#123;</div><div class="line">            return end;</div><div class="line">        &#125;</div><div class="line">        if (target == A[start]) &#123;</div><div class="line">            return start;</div><div class="line">        &#125;</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="question-4-search-insert-position">Question 4: search-insert-position</h3>
<p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>
<p>You may assume NO duplicates in the array.</p>
<p>[1,3,5,6], 5 → 2</p>
<p>[1,3,5,6], 2 → 1</p>
<p>[1,3,5,6], 7 → 4</p>
<p>[1,3,5,6], 0 → 0</p>
<h3 id="code">Code</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    /**</div><div class="line">     * param A : an integer sorted array</div><div class="line">     * param target :  an integer to be inserted</div><div class="line">     * return : an integer</div><div class="line">     */</div><div class="line">    public int searchInsert(int[] A, int target) &#123;</div><div class="line">        // write your code here</div><div class="line">        if ( A == null || A.length == 0) return 0;</div><div class="line">        int start = 0;</div><div class="line">        int end = A.length - 1;</div><div class="line">        while (start + 1 &lt; end) &#123;</div><div class="line">            int mid = start + (end - start) / 2;</div><div class="line">            if (target == A[mid]) &#123;</div><div class="line">                return mid;</div><div class="line">            &#125; else if (target &gt; A[mid]) &#123;</div><div class="line">                start = mid;</div><div class="line">            &#125; else &#123;</div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (target &lt;= A[start]) return start;</div><div class="line">        if (target &lt;= A[end]) return end;</div><div class="line">        return end + 1;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="question-5-search-in-a-big-sorted-array">Question 5: Search in a big sorted array</h3>
<p>Given a big sorted array with positive integers sorted by ascending order. The array is so big so that you can not get the length of the whole array directly, and you can only access the kth number by ArrayReader.get(k) (or ArrayReader-&gt;get(k) for C++). Find the first index of a target number. Your algorithm should be in O(log k), where k is the first index of the target number.
Return -1, if the number doesn't exist in the array.</p>
<h3 id="explanation">Explanation</h3>
<p>本题和上面考察如何在一个array中找到一个数不同的是，这个array会非常大。所以要考虑的是如何“倍增”的问题。增到大于target就可以了，接下来找到最初出现的问题。</p>
<h3 id="code">Code</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">    /**</div><div class="line">     * @param nums: The integer array.</div><div class="line">     * @param target: Target to find.</div><div class="line">     * @return: The first position of target. Position starts from 0.</div><div class="line">     */</div><div class="line">    public int binarySearch(int[] nums, int target) &#123;</div><div class="line">        //write your code here</div><div class="line">        if (nums == null || nums.length == 0) return -1;</div><div class="line">        int end = 0;</div><div class="line">        while (end &lt; nums.length &amp;&amp; nums[end] &lt; target) &#123;</div><div class="line">          end = end * 2 + 1;</div><div class="line">        &#125;</div><div class="line">        if (end &gt;= nums.length) end = nums.length - 1;</div><div class="line">        int start = 0;</div><div class="line">        while (start + 1 &lt; end) &#123;</div><div class="line">            int mid = start + (end - start) / 2;</div><div class="line">            if (target == nums[mid]) &#123;</div><div class="line">                end = mid;</div><div class="line">            &#125; else if (target &gt; nums[mid]) &#123;</div><div class="line">                start = mid;</div><div class="line">            &#125; else &#123;</div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (target == nums[start]) return start;</div><div class="line">        if (target == nums[end]) return end;</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;二分查找模板总结&quot;&gt;二分查找模板总结&lt;/h2&gt;
&lt;p&gt;四点要素：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;start + 1 &amp;lt; end&lt;/li&gt;
&lt;li&gt;start + 
    
    </summary>
    
      <category term="Data Structure" scheme="http://yoursite.com/categories/Data-Structure/"/>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/tags/Data-Structure/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Backtracking Problems</title>
    <link href="http://yoursite.com/2017/05/25/LeetCode-Backtracking-Problems/"/>
    <id>http://yoursite.com/2017/05/25/LeetCode-Backtracking-Problems/</id>
    <published>2017-05-25T13:08:29.000Z</published>
    <updated>2017-05-28T18:23:20.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><h2 id="leetcode-78-subsets">LeetCode 78: Subsets</h2>
<h3 id="question">Question</h3>
<p>Given a set of distinct integers, nums, return all possible subsets.</p>
<p>Note: The solution set must not contain duplicate subsets.</p>
<p>For example,
If nums = [1,2,3], a solution is:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [3],</div><div class="line">  [1],</div><div class="line">  [2],</div><div class="line">  [1,2,3],</div><div class="line">  [1,3],</div><div class="line">  [2,3],</div><div class="line">  [1,2],</div><div class="line">  []</div><div class="line">]</div></pre></td></tr></table></figure></p>
<h3 id="explanation">Explanation</h3>
<p>回溯递归</p>
<h3 id="code">Code</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123;</div><div class="line">    List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();</div><div class="line">    Arrays.sort(nums);</div><div class="line">    subsetsHelper(list, new ArrayList&lt;&gt;(),nums, 0);</div><div class="line">    return list;</div><div class="line">&#125;</div><div class="line">public void subsetsHelper(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tmpList, int[] nums, int start) &#123;</div><div class="line">    System.out.println(tmpList.toString());</div><div class="line">    list.add(new ArrayList&lt;&gt;(tmpList));</div><div class="line">    for (int i=start; i&lt;nums.length; i++) &#123;</div><div class="line">        System.out.println(i);</div><div class="line">        tmpList.add(nums[i]);</div><div class="line">        subsetsHelper(list, tmpList, nums, i+1);</div><div class="line">        tmpList.remove(tmpList.size()-1);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="leetcode-90-subsets-ii">LeetCode 90. Subsets II</h2>
<h3 id="question">Question</h3>
<p>Given a collection of integers that might contain duplicates, nums, return all possible subsets.</p>
<p>Note: The solution set must not contain duplicate subsets.</p>
<p>For example,
If nums = [1,2,2], a solution is:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [2],</div><div class="line">  [1],</div><div class="line">  [1,2,2],</div><div class="line">  [2,2],</div><div class="line">  [1,2],</div><div class="line">  []</div><div class="line">]</div></pre></td></tr></table></figure></p>
<h3 id="explanation">Explanation</h3>
<p>和上一题一致，只是对于重复的，skip掉。</p>
<h3 id="code">Code</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123;</div><div class="line">    List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();</div><div class="line">    Arrays.sort(nums);</div><div class="line">    subsetsHelper(list, new ArrayList&lt;&gt;(),nums, 0);</div><div class="line">    return list;</div><div class="line">&#125;</div><div class="line">public void subsetsHelper(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tmpList, int[] nums, int start) &#123;</div><div class="line">    System.out.println(tmpList.toString());</div><div class="line">    list.add(new ArrayList&lt;&gt;(tmpList));</div><div class="line">    for (int i=start; i&lt;nums.length; i++) &#123;</div><div class="line">        if (i != start &amp;&amp; nums[i] == nums[i-1] ) continue;</div><div class="line">        tmpList.add(nums[i]);</div><div class="line">        subsetsHelper(list, tmpList, nums, i+1);</div><div class="line">        tmpList.remove(tmpList.size()-1);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="leecode-46-permutations">LeeCode 46. Permutations</h2>
<h3 id="question">Question</h3>
<p>Given a collection of distinct numbers, return all possible permutations.</p>
<p>For example,
[1,2,3] have the following permutations:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [1,2,3],</div><div class="line">  [1,3,2],</div><div class="line">  [2,1,3],</div><div class="line">  [2,3,1],</div><div class="line">  [3,1,2],</div><div class="line">  [3,2,1]</div><div class="line">]</div></pre></td></tr></table></figure></p>
<h3 id="explanation">Explanation</h3>
<h3 id="code">Code</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;</div><div class="line">        List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();</div><div class="line">        subsetsHelper(list, new ArrayList&lt;&gt;(),nums);</div><div class="line">        return list;</div><div class="line">    &#125;</div><div class="line">    public void subsetsHelper(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tmpList, int[] nums) &#123;</div><div class="line">        if (tmpList.size() == nums.length) &#123;</div><div class="line">            list.add(new ArrayList&lt;&gt;(tmpList));</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            for (int i= 0; i&lt;nums.length; i++) &#123;</div><div class="line">                if (tmpList.contains(nums[i])) continue;</div><div class="line">                tmpList.add(nums[i]);</div><div class="line">                subsetsHelper(list, tmpList, nums);</div><div class="line">                tmpList.remove(tmpList.size()-1);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;leetcode-78-subsets&quot;&gt;LeetCode 78: Subsets&lt;/h2&gt;
&lt;h3 id=&quot;question&quot;&gt;Question&lt;/h3&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>Install Sudo in Debian</title>
    <link href="http://yoursite.com/2017/04/28/Install-Sudo-in-Debian/"/>
    <id>http://yoursite.com/2017/04/28/Install-Sudo-in-Debian/</id>
    <published>2017-04-29T02:21:34.000Z</published>
    <updated>2017-04-29T02:26:58.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><p>Debian系统里默认是没有sudo的，安装操作如下。</p>
<p>Step 1: 用root的身份进入<br>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">su -u</div></pre></td></tr></table></figure></p>
<p>Step 2: 安装sudo
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt-get install sudo</div></pre></td></tr></table></figure></p>
<p>Step 3: 把你的用户名加入sudoer列表中
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi /etc/sudoers</div></pre></td></tr></table></figure></p>
<p>编辑此文件，加入这样一句：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">star ALL=(ALL:ALL) ALL</div></pre></td></tr></table></figure></p>
<p>Step 4: 退出root，测试sudo
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">exit</div><div class="line"></div><div class="line">sudo su -</div></pre></td></tr></table></figure></p>
<p>Done!</p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;Debian系统里默认是没有sudo的，安装操作如下。&lt;/p&gt;
&lt;p&gt;Step 1: 用root的身份进入&lt;br&gt;
&lt;figure class=&quot;highlight plai
    
    </summary>
    
      <category term="技术冷板凳" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%86%B7%E6%9D%BF%E5%87%B3/"/>
    
    
      <category term="Debian" scheme="http://yoursite.com/tags/Debian/"/>
    
      <category term="sudo" scheme="http://yoursite.com/tags/sudo/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 438. Find All Anagrams in a String</title>
    <link href="http://yoursite.com/2017/04/24/LeetCode-438-Find-All-Anagrams-in-a-String/"/>
    <id>http://yoursite.com/2017/04/24/LeetCode-438-Find-All-Anagrams-in-a-String/</id>
    <published>2017-04-24T18:19:26.000Z</published>
    <updated>2017-04-24T19:51:33.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><h4 id="question">Question:</h4>
<p>Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.</p>
<p>Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.</p>
<p>The order of output does not matter.</p>
<p>Example 1:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Input:</div><div class="line">s: &quot;cbaebabacd&quot; p: &quot;abc&quot;</div><div class="line"></div><div class="line">Output:</div><div class="line">[0, 6]</div><div class="line"></div><div class="line">Explanation:</div><div class="line">The substring with start index = 0 is &quot;cba&quot;, which is an anagram of &quot;abc&quot;.</div><div class="line">The substring with start index = 6 is &quot;bac&quot;, which is an anagram of &quot;abc&quot;.</div></pre></td></tr></table></figure></p>
<p>Example 2:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Input:</div><div class="line">s: &quot;abab&quot; p: &quot;ab&quot;</div><div class="line"></div><div class="line">Output:</div><div class="line">[0, 1, 2]</div><div class="line"></div><div class="line">Explanation:</div><div class="line">The substring with start index = 0 is &quot;ab&quot;, which is an anagram of &quot;ab&quot;.</div><div class="line">The substring with start index = 1 is &quot;ba&quot;, which is an anagram of &quot;ab&quot;.</div><div class="line">The substring with start index = 2 is &quot;ab&quot;, which is an anagram of &quot;ab&quot;.</div></pre></td></tr></table></figure></p>
<h4 id="explanation">Explanation</h4>
<p>暴力解会超时。需要采用sliding window的方法。
参照 https://discuss.leetcode.com/topic/64434/shortest-concise-java-o-n-sliding-window-solution
另外还有一些总结的模板：
https://discuss.leetcode.com/topic/30941/here-is-a-10-line-template-that-can-solve-most-substring-problems</p>
<h4 id="code">Code</h4>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">public List&lt;Integer&gt; findAnagrams(String s, String p) &#123;</div><div class="line">    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</div><div class="line">    if(s == null || p == null || s.length() &lt; p.length()) return list;</div><div class="line">    int[] chars = new int[256];</div><div class="line">    for(Character c:p.toCharArray()) &#123;</div><div class="line">        chars[c] ++;</div><div class="line">    &#125;</div><div class="line">    int start = 0; int end = 0; int count = p.length();</div><div class="line">    while(end &lt; s.length()) &#123;</div><div class="line">        //move right everytime, if the character exists in p&apos;s hash, decrease the count</div><div class="line">        //current hash value &gt;= 1 means the character is existing in p</div><div class="line">        if (chars[s.charAt(end)] &gt;= 1) &#123;</div><div class="line">            count--;</div><div class="line">        &#125;</div><div class="line">        chars[s.charAt(end)]--;</div><div class="line">        end++;</div><div class="line"></div><div class="line">        //when the count is down to 0, means we found the right anagram</div><div class="line">        //then add window&apos;s left to result list</div><div class="line">        if (count == 0) &#123;</div><div class="line">            list.add(start);</div><div class="line">        &#125;</div><div class="line">        //if we find the window&apos;s size equals to p, then we have to move left (narrow the window) to find the new match window</div><div class="line">        //++ to reset the hash because we kicked out the left</div><div class="line">        //only increase the count if the character is in p</div><div class="line">        //the count &gt;= 0 indicate it was original in the hash, cuz it won&apos;t go below 0</div><div class="line">        if (end - start== p.length() ) &#123;</div><div class="line">            if (chars[s.charAt(start)] &gt;= 0) &#123;</div><div class="line">                count++;</div><div class="line">            &#125;</div><div class="line">            chars[s.charAt(start)]++;</div><div class="line">            start++;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return list;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h4 id=&quot;question&quot;&gt;Question:&lt;/h4&gt;
&lt;p&gt;Given a string s and a non-empty string p, find all th
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
  </entry>
  
</feed>
